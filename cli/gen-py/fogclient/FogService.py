#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def joinCluster(self, NodeX, pmin, pmax):
        """
        Parameters:
         - NodeX
         - pmin
         - pmax
        """
        pass

    def joinPool(self, NodeX):
        """
        Parameters:
         - NodeX
        """
        pass

    def getCandidatePool(self, reliability, pmin):
        """
        Parameters:
         - reliability
         - pmin
        """
        pass

    def bootstrapFog(self, NodeX):
        """
        Parameters:
         - NodeX
        """
        pass

    def initiate2PhasePreCommit(self, preCommitRequest):
        """
        Parameters:
         - preCommitRequest
        """
        pass

    def initiate2PhaseCommit(self, commitRequest):
        """
        Parameters:
         - commitRequest
        """
        pass

    def buddyHeartBeat(self, payload):
        """
        Parameters:
         - payload
        """
        pass

    def neighborHeartBeat(self, payload):
        """
        Parameters:
         - payload
        """
        pass

    def getPoolMember(self, buddyPoolId):
        """
        Parameters:
         - buddyPoolId
        """
        pass

    def getBuddyPoolMembers(self):
        pass

    def getNeighborCountPerPool(self):
        pass

    def requestNeighbors(self, requestMap):
        """
        Parameters:
         - requestMap
        """
        pass

    def nodeJoiningComplete(self):
        pass

    def subscribe(self, nodeInfoData):
        """
        Parameters:
         - nodeInfoData
        """
        pass

    def edgeHeartBeats(self, edgePayload):
        """
        Parameters:
         - edgePayload
        """
        pass

    def edgeJoin(self, edgeInfoData):
        """
        Parameters:
         - edgeInfoData
        """
        pass

    def edgeLeave(self, edgeInfoData):
        """
        Parameters:
         - edgeInfoData
        """
        pass

    def terminate(self, streamId):
        """
        Parameters:
         - streamId
        """
        pass

    def registerStream(self, streamId, streamMetadata, startSequenceNumber):
        """
        Parameters:
         - streamId
         - streamMetadata
         - startSequenceNumber
        """
        pass

    def intentToWrite(self, clientId):
        """
        Parameters:
         - clientId
        """
        pass

    def getStreamMetadata(self, streamId, checkNeighbors, checkBuddies, forceLatest):
        """
        Parameters:
         - streamId
         - checkNeighbors
         - checkBuddies
         - forceLatest
        """
        pass

    def getStreamMetadataFromOwner(self, streamId):
        """
        Parameters:
         - streamId
        """
        pass

    def getWriteLocations(self, dataLength, metadata, blackListedFogs, isEdge):
        """
        Parameters:
         - dataLength
         - metadata
         - blackListedFogs
         - isEdge
        """
        pass

    def write(self, mbMetadata, data, preference):
        """
        Parameters:
         - mbMetadata
         - data
         - preference
        """
        pass

    def writeNext(self, sessionId, mbData, dataLength):
        """
        Parameters:
         - sessionId
         - mbData
         - dataLength
        """
        pass

    def insertMetadata(self, mbMetadata, edgeInfoData, metaKeyValueMap):
        """
        Parameters:
         - mbMetadata
         - edgeInfoData
         - metaKeyValueMap
        """
        pass

    def findNext(self, microbatchId):
        """
        Parameters:
         - microbatchId
        """
        pass

    def find(self, microbatchId, checkNeighbors, checkBuddies, selfInfo):
        """
        Parameters:
         - microbatchId
         - checkNeighbors
         - checkBuddies
         - selfInfo
        """
        pass

    def findFast(self, microbatchIdList, checkNeighbors, checkBuddies, selfInfo):
        """
        Parameters:
         - microbatchIdList
         - checkNeighbors
         - checkBuddies
         - selfInfo
        """
        pass

    def read(self, microbatchId, fetchMetadata, compFormat, uncompSize):
        """
        Parameters:
         - microbatchId
         - fetchMetadata
         - compFormat
         - uncompSize
        """
        pass

    def findUsingQuery(self, metadataKey, metadataValue, checkNeighbors, checkBuddies):
        """
        Parameters:
         - metadataKey
         - metadataValue
         - checkNeighbors
         - checkBuddies
        """
        pass

    def getMeta(self, microbatchId, checkNeighbors, checkBuddies):
        """
        Parameters:
         - microbatchId
         - checkNeighbors
         - checkBuddies
        """
        pass

    def serializeState(self):
        pass

    def updateStreamMetadata(self, metadata):
        """
        Parameters:
         - metadata
        """
        pass

    def open(self, streamId, clientId, expectedLease, setLease):
        """
        Parameters:
         - streamId
         - clientId
         - expectedLease
         - setLease
        """
        pass

    def putNext(self, mbMetadata, data, preference, metaKeyValueMap):
        """
        Parameters:
         - mbMetadata
         - data
         - preference
         - metaKeyValueMap
        """
        pass

    def incrementBlockCount(self, mbMetadata, setLease):
        """
        Parameters:
         - mbMetadata
         - setLease
        """
        pass

    def renewLease(self, streamId, clientId, sessionSecret, expectedLease, setLease):
        """
        Parameters:
         - streamId
         - clientId
         - sessionSecret
         - expectedLease
         - setLease
        """
        pass

    def getLargestBlockId(self, streamId):
        """
        Parameters:
         - streamId
        """
        pass

    def findStream(self, squery):
        """
        Parameters:
         - squery
        """
        pass

    def updateBlock(self, mbId, mbMetadata, mbData):
        """
        Parameters:
         - mbId
         - mbMetadata
         - mbData
        """
        pass

    def listLocalPartitionMbId(self, flag):
        """
        Parameters:
         - flag
        """
        pass

    def requestAllNeighbors(self):
        pass

    def requestEdgeMicrobatchMap(self):
        pass

    def requestCompFormatSize(self, mbId):
        """
        Parameters:
         - mbId
        """
        pass

    def findStreamUsingQuery(self, metaKeyValueMap, checkNeighbors, checkBuddies):
        """
        Parameters:
         - metaKeyValueMap
         - checkNeighbors
         - checkBuddies
        """
        pass

    def findBlockUsingQuery(self, metaKeyValueMap, checkNeighbors, checkBuddies, matchpreference):
        """
        Parameters:
         - metaKeyValueMap
         - checkNeighbors
         - checkBuddies
         - matchpreference
        """
        pass

    def findBlocksAndLocationsWithQuery(self, checkNeighbors, checkBuddies, queryCondition, replicacount, edgeInfo):
        """
        Parameters:
         - checkNeighbors
         - checkBuddies
         - queryCondition
         - replicacount
         - edgeInfo
        """
        pass

    def getMetadataByBlockid(self, mbid, fogip, fogport, edgeInfoData, keys):
        """
        Parameters:
         - mbid
         - fogip
         - fogport
         - edgeInfoData
         - keys
        """
        pass

    def getManyMetadataByBlockidList(self, mbidList, fogip, fogport, edgeInfoData, keys):
        """
        Parameters:
         - mbidList
         - fogip
         - fogport
         - edgeInfoData
         - keys
        """
        pass

    def putData(self, mbMetadata, version, data, preference, metaKeyValueMap, clientId):
        """
        Parameters:
         - mbMetadata
         - version
         - data
         - preference
         - metaKeyValueMap
         - clientId
        """
        pass

    def putDataQuorum(self, mbMetadata, version, data, metaKeyValueMap, clientid):
        """
        Parameters:
         - mbMetadata
         - version
         - data
         - metaKeyValueMap
         - clientid
        """
        pass

    def get(self, microbatchId, fetchMetadata, compFormat, uncompSize, clientId):
        """
        Parameters:
         - microbatchId
         - fetchMetadata
         - compFormat
         - uncompSize
         - clientId
        """
        pass

    def getData(self, microbatchId, fetchMetadata, compFormat, uncompSize, selfInfo):
        """
        Parameters:
         - microbatchId
         - fetchMetadata
         - compFormat
         - uncompSize
         - selfInfo
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def joinCluster(self, NodeX, pmin, pmax):
        """
        Parameters:
         - NodeX
         - pmin
         - pmax
        """
        self.send_joinCluster(NodeX, pmin, pmax)
        return self.recv_joinCluster()

    def send_joinCluster(self, NodeX, pmin, pmax):
        self._oprot.writeMessageBegin('joinCluster', TMessageType.CALL, self._seqid)
        args = joinCluster_args()
        args.NodeX = NodeX
        args.pmin = pmin
        args.pmax = pmax
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_joinCluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = joinCluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "joinCluster failed: unknown result")

    def joinPool(self, NodeX):
        """
        Parameters:
         - NodeX
        """
        self.send_joinPool(NodeX)
        return self.recv_joinPool()

    def send_joinPool(self, NodeX):
        self._oprot.writeMessageBegin('joinPool', TMessageType.CALL, self._seqid)
        args = joinPool_args()
        args.NodeX = NodeX
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_joinPool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = joinPool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "joinPool failed: unknown result")

    def getCandidatePool(self, reliability, pmin):
        """
        Parameters:
         - reliability
         - pmin
        """
        self.send_getCandidatePool(reliability, pmin)
        return self.recv_getCandidatePool()

    def send_getCandidatePool(self, reliability, pmin):
        self._oprot.writeMessageBegin('getCandidatePool', TMessageType.CALL, self._seqid)
        args = getCandidatePool_args()
        args.reliability = reliability
        args.pmin = pmin
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCandidatePool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCandidatePool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCandidatePool failed: unknown result")

    def bootstrapFog(self, NodeX):
        """
        Parameters:
         - NodeX
        """
        self.send_bootstrapFog(NodeX)
        return self.recv_bootstrapFog()

    def send_bootstrapFog(self, NodeX):
        self._oprot.writeMessageBegin('bootstrapFog', TMessageType.CALL, self._seqid)
        args = bootstrapFog_args()
        args.NodeX = NodeX
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_bootstrapFog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = bootstrapFog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "bootstrapFog failed: unknown result")

    def initiate2PhasePreCommit(self, preCommitRequest):
        """
        Parameters:
         - preCommitRequest
        """
        self.send_initiate2PhasePreCommit(preCommitRequest)
        return self.recv_initiate2PhasePreCommit()

    def send_initiate2PhasePreCommit(self, preCommitRequest):
        self._oprot.writeMessageBegin('initiate2PhasePreCommit', TMessageType.CALL, self._seqid)
        args = initiate2PhasePreCommit_args()
        args.preCommitRequest = preCommitRequest
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_initiate2PhasePreCommit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = initiate2PhasePreCommit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "initiate2PhasePreCommit failed: unknown result")

    def initiate2PhaseCommit(self, commitRequest):
        """
        Parameters:
         - commitRequest
        """
        self.send_initiate2PhaseCommit(commitRequest)
        return self.recv_initiate2PhaseCommit()

    def send_initiate2PhaseCommit(self, commitRequest):
        self._oprot.writeMessageBegin('initiate2PhaseCommit', TMessageType.CALL, self._seqid)
        args = initiate2PhaseCommit_args()
        args.commitRequest = commitRequest
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_initiate2PhaseCommit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = initiate2PhaseCommit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "initiate2PhaseCommit failed: unknown result")

    def buddyHeartBeat(self, payload):
        """
        Parameters:
         - payload
        """
        self.send_buddyHeartBeat(payload)

    def send_buddyHeartBeat(self, payload):
        self._oprot.writeMessageBegin('buddyHeartBeat', TMessageType.ONEWAY, self._seqid)
        args = buddyHeartBeat_args()
        args.payload = payload
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def neighborHeartBeat(self, payload):
        """
        Parameters:
         - payload
        """
        self.send_neighborHeartBeat(payload)

    def send_neighborHeartBeat(self, payload):
        self._oprot.writeMessageBegin('neighborHeartBeat', TMessageType.ONEWAY, self._seqid)
        args = neighborHeartBeat_args()
        args.payload = payload
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def getPoolMember(self, buddyPoolId):
        """
        Parameters:
         - buddyPoolId
        """
        self.send_getPoolMember(buddyPoolId)
        return self.recv_getPoolMember()

    def send_getPoolMember(self, buddyPoolId):
        self._oprot.writeMessageBegin('getPoolMember', TMessageType.CALL, self._seqid)
        args = getPoolMember_args()
        args.buddyPoolId = buddyPoolId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPoolMember(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPoolMember_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPoolMember failed: unknown result")

    def getBuddyPoolMembers(self):
        self.send_getBuddyPoolMembers()
        return self.recv_getBuddyPoolMembers()

    def send_getBuddyPoolMembers(self):
        self._oprot.writeMessageBegin('getBuddyPoolMembers', TMessageType.CALL, self._seqid)
        args = getBuddyPoolMembers_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getBuddyPoolMembers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getBuddyPoolMembers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getBuddyPoolMembers failed: unknown result")

    def getNeighborCountPerPool(self):
        self.send_getNeighborCountPerPool()
        return self.recv_getNeighborCountPerPool()

    def send_getNeighborCountPerPool(self):
        self._oprot.writeMessageBegin('getNeighborCountPerPool', TMessageType.CALL, self._seqid)
        args = getNeighborCountPerPool_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNeighborCountPerPool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNeighborCountPerPool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNeighborCountPerPool failed: unknown result")

    def requestNeighbors(self, requestMap):
        """
        Parameters:
         - requestMap
        """
        self.send_requestNeighbors(requestMap)
        return self.recv_requestNeighbors()

    def send_requestNeighbors(self, requestMap):
        self._oprot.writeMessageBegin('requestNeighbors', TMessageType.CALL, self._seqid)
        args = requestNeighbors_args()
        args.requestMap = requestMap
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_requestNeighbors(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = requestNeighbors_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "requestNeighbors failed: unknown result")

    def nodeJoiningComplete(self):
        self.send_nodeJoiningComplete()
        self.recv_nodeJoiningComplete()

    def send_nodeJoiningComplete(self):
        self._oprot.writeMessageBegin('nodeJoiningComplete', TMessageType.CALL, self._seqid)
        args = nodeJoiningComplete_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_nodeJoiningComplete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = nodeJoiningComplete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def subscribe(self, nodeInfoData):
        """
        Parameters:
         - nodeInfoData
        """
        self.send_subscribe(nodeInfoData)
        return self.recv_subscribe()

    def send_subscribe(self, nodeInfoData):
        self._oprot.writeMessageBegin('subscribe', TMessageType.CALL, self._seqid)
        args = subscribe_args()
        args.nodeInfoData = nodeInfoData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_subscribe(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = subscribe_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "subscribe failed: unknown result")

    def edgeHeartBeats(self, edgePayload):
        """
        Parameters:
         - edgePayload
        """
        self.send_edgeHeartBeats(edgePayload)
        return self.recv_edgeHeartBeats()

    def send_edgeHeartBeats(self, edgePayload):
        self._oprot.writeMessageBegin('edgeHeartBeats', TMessageType.CALL, self._seqid)
        args = edgeHeartBeats_args()
        args.edgePayload = edgePayload
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_edgeHeartBeats(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = edgeHeartBeats_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "edgeHeartBeats failed: unknown result")

    def edgeJoin(self, edgeInfoData):
        """
        Parameters:
         - edgeInfoData
        """
        self.send_edgeJoin(edgeInfoData)
        return self.recv_edgeJoin()

    def send_edgeJoin(self, edgeInfoData):
        self._oprot.writeMessageBegin('edgeJoin', TMessageType.CALL, self._seqid)
        args = edgeJoin_args()
        args.edgeInfoData = edgeInfoData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_edgeJoin(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = edgeJoin_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "edgeJoin failed: unknown result")

    def edgeLeave(self, edgeInfoData):
        """
        Parameters:
         - edgeInfoData
        """
        self.send_edgeLeave(edgeInfoData)
        return self.recv_edgeLeave()

    def send_edgeLeave(self, edgeInfoData):
        self._oprot.writeMessageBegin('edgeLeave', TMessageType.CALL, self._seqid)
        args = edgeLeave_args()
        args.edgeInfoData = edgeInfoData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_edgeLeave(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = edgeLeave_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "edgeLeave failed: unknown result")

    def terminate(self, streamId):
        """
        Parameters:
         - streamId
        """
        self.send_terminate(streamId)
        return self.recv_terminate()

    def send_terminate(self, streamId):
        self._oprot.writeMessageBegin('terminate', TMessageType.CALL, self._seqid)
        args = terminate_args()
        args.streamId = streamId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_terminate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = terminate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "terminate failed: unknown result")

    def registerStream(self, streamId, streamMetadata, startSequenceNumber):
        """
        Parameters:
         - streamId
         - streamMetadata
         - startSequenceNumber
        """
        self.send_registerStream(streamId, streamMetadata, startSequenceNumber)
        return self.recv_registerStream()

    def send_registerStream(self, streamId, streamMetadata, startSequenceNumber):
        self._oprot.writeMessageBegin('registerStream', TMessageType.CALL, self._seqid)
        args = registerStream_args()
        args.streamId = streamId
        args.streamMetadata = streamMetadata
        args.startSequenceNumber = startSequenceNumber
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_registerStream(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = registerStream_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "registerStream failed: unknown result")

    def intentToWrite(self, clientId):
        """
        Parameters:
         - clientId
        """
        self.send_intentToWrite(clientId)
        return self.recv_intentToWrite()

    def send_intentToWrite(self, clientId):
        self._oprot.writeMessageBegin('intentToWrite', TMessageType.CALL, self._seqid)
        args = intentToWrite_args()
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_intentToWrite(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = intentToWrite_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "intentToWrite failed: unknown result")

    def getStreamMetadata(self, streamId, checkNeighbors, checkBuddies, forceLatest):
        """
        Parameters:
         - streamId
         - checkNeighbors
         - checkBuddies
         - forceLatest
        """
        self.send_getStreamMetadata(streamId, checkNeighbors, checkBuddies, forceLatest)
        return self.recv_getStreamMetadata()

    def send_getStreamMetadata(self, streamId, checkNeighbors, checkBuddies, forceLatest):
        self._oprot.writeMessageBegin('getStreamMetadata', TMessageType.CALL, self._seqid)
        args = getStreamMetadata_args()
        args.streamId = streamId
        args.checkNeighbors = checkNeighbors
        args.checkBuddies = checkBuddies
        args.forceLatest = forceLatest
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getStreamMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getStreamMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getStreamMetadata failed: unknown result")

    def getStreamMetadataFromOwner(self, streamId):
        """
        Parameters:
         - streamId
        """
        self.send_getStreamMetadataFromOwner(streamId)
        return self.recv_getStreamMetadataFromOwner()

    def send_getStreamMetadataFromOwner(self, streamId):
        self._oprot.writeMessageBegin('getStreamMetadataFromOwner', TMessageType.CALL, self._seqid)
        args = getStreamMetadataFromOwner_args()
        args.streamId = streamId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getStreamMetadataFromOwner(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getStreamMetadataFromOwner_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getStreamMetadataFromOwner failed: unknown result")

    def getWriteLocations(self, dataLength, metadata, blackListedFogs, isEdge):
        """
        Parameters:
         - dataLength
         - metadata
         - blackListedFogs
         - isEdge
        """
        self.send_getWriteLocations(dataLength, metadata, blackListedFogs, isEdge)
        return self.recv_getWriteLocations()

    def send_getWriteLocations(self, dataLength, metadata, blackListedFogs, isEdge):
        self._oprot.writeMessageBegin('getWriteLocations', TMessageType.CALL, self._seqid)
        args = getWriteLocations_args()
        args.dataLength = dataLength
        args.metadata = metadata
        args.blackListedFogs = blackListedFogs
        args.isEdge = isEdge
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getWriteLocations(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getWriteLocations_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getWriteLocations failed: unknown result")

    def write(self, mbMetadata, data, preference):
        """
        Parameters:
         - mbMetadata
         - data
         - preference
        """
        self.send_write(mbMetadata, data, preference)
        return self.recv_write()

    def send_write(self, mbMetadata, data, preference):
        self._oprot.writeMessageBegin('write', TMessageType.CALL, self._seqid)
        args = write_args()
        args.mbMetadata = mbMetadata
        args.data = data
        args.preference = preference
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write failed: unknown result")

    def writeNext(self, sessionId, mbData, dataLength):
        """
        Parameters:
         - sessionId
         - mbData
         - dataLength
        """
        self.send_writeNext(sessionId, mbData, dataLength)
        return self.recv_writeNext()

    def send_writeNext(self, sessionId, mbData, dataLength):
        self._oprot.writeMessageBegin('writeNext', TMessageType.CALL, self._seqid)
        args = writeNext_args()
        args.sessionId = sessionId
        args.mbData = mbData
        args.dataLength = dataLength
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_writeNext(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = writeNext_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "writeNext failed: unknown result")

    def insertMetadata(self, mbMetadata, edgeInfoData, metaKeyValueMap):
        """
        Parameters:
         - mbMetadata
         - edgeInfoData
         - metaKeyValueMap
        """
        self.send_insertMetadata(mbMetadata, edgeInfoData, metaKeyValueMap)
        return self.recv_insertMetadata()

    def send_insertMetadata(self, mbMetadata, edgeInfoData, metaKeyValueMap):
        self._oprot.writeMessageBegin('insertMetadata', TMessageType.CALL, self._seqid)
        args = insertMetadata_args()
        args.mbMetadata = mbMetadata
        args.edgeInfoData = edgeInfoData
        args.metaKeyValueMap = metaKeyValueMap
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_insertMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = insertMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "insertMetadata failed: unknown result")

    def findNext(self, microbatchId):
        """
        Parameters:
         - microbatchId
        """
        self.send_findNext(microbatchId)
        return self.recv_findNext()

    def send_findNext(self, microbatchId):
        self._oprot.writeMessageBegin('findNext', TMessageType.CALL, self._seqid)
        args = findNext_args()
        args.microbatchId = microbatchId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findNext(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findNext_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findNext failed: unknown result")

    def find(self, microbatchId, checkNeighbors, checkBuddies, selfInfo):
        """
        Parameters:
         - microbatchId
         - checkNeighbors
         - checkBuddies
         - selfInfo
        """
        self.send_find(microbatchId, checkNeighbors, checkBuddies, selfInfo)
        return self.recv_find()

    def send_find(self, microbatchId, checkNeighbors, checkBuddies, selfInfo):
        self._oprot.writeMessageBegin('find', TMessageType.CALL, self._seqid)
        args = find_args()
        args.microbatchId = microbatchId
        args.checkNeighbors = checkNeighbors
        args.checkBuddies = checkBuddies
        args.selfInfo = selfInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_find(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = find_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "find failed: unknown result")

    def findFast(self, microbatchIdList, checkNeighbors, checkBuddies, selfInfo):
        """
        Parameters:
         - microbatchIdList
         - checkNeighbors
         - checkBuddies
         - selfInfo
        """
        self.send_findFast(microbatchIdList, checkNeighbors, checkBuddies, selfInfo)
        return self.recv_findFast()

    def send_findFast(self, microbatchIdList, checkNeighbors, checkBuddies, selfInfo):
        self._oprot.writeMessageBegin('findFast', TMessageType.CALL, self._seqid)
        args = findFast_args()
        args.microbatchIdList = microbatchIdList
        args.checkNeighbors = checkNeighbors
        args.checkBuddies = checkBuddies
        args.selfInfo = selfInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findFast(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findFast_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findFast failed: unknown result")

    def read(self, microbatchId, fetchMetadata, compFormat, uncompSize):
        """
        Parameters:
         - microbatchId
         - fetchMetadata
         - compFormat
         - uncompSize
        """
        self.send_read(microbatchId, fetchMetadata, compFormat, uncompSize)
        return self.recv_read()

    def send_read(self, microbatchId, fetchMetadata, compFormat, uncompSize):
        self._oprot.writeMessageBegin('read', TMessageType.CALL, self._seqid)
        args = read_args()
        args.microbatchId = microbatchId
        args.fetchMetadata = fetchMetadata
        args.compFormat = compFormat
        args.uncompSize = uncompSize
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read failed: unknown result")

    def findUsingQuery(self, metadataKey, metadataValue, checkNeighbors, checkBuddies):
        """
        Parameters:
         - metadataKey
         - metadataValue
         - checkNeighbors
         - checkBuddies
        """
        self.send_findUsingQuery(metadataKey, metadataValue, checkNeighbors, checkBuddies)
        return self.recv_findUsingQuery()

    def send_findUsingQuery(self, metadataKey, metadataValue, checkNeighbors, checkBuddies):
        self._oprot.writeMessageBegin('findUsingQuery', TMessageType.CALL, self._seqid)
        args = findUsingQuery_args()
        args.metadataKey = metadataKey
        args.metadataValue = metadataValue
        args.checkNeighbors = checkNeighbors
        args.checkBuddies = checkBuddies
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findUsingQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findUsingQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findUsingQuery failed: unknown result")

    def getMeta(self, microbatchId, checkNeighbors, checkBuddies):
        """
        Parameters:
         - microbatchId
         - checkNeighbors
         - checkBuddies
        """
        self.send_getMeta(microbatchId, checkNeighbors, checkBuddies)
        return self.recv_getMeta()

    def send_getMeta(self, microbatchId, checkNeighbors, checkBuddies):
        self._oprot.writeMessageBegin('getMeta', TMessageType.CALL, self._seqid)
        args = getMeta_args()
        args.microbatchId = microbatchId
        args.checkNeighbors = checkNeighbors
        args.checkBuddies = checkBuddies
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMeta(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMeta_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMeta failed: unknown result")

    def serializeState(self):
        self.send_serializeState()
        return self.recv_serializeState()

    def send_serializeState(self):
        self._oprot.writeMessageBegin('serializeState', TMessageType.CALL, self._seqid)
        args = serializeState_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_serializeState(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = serializeState_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "serializeState failed: unknown result")

    def updateStreamMetadata(self, metadata):
        """
        Parameters:
         - metadata
        """
        self.send_updateStreamMetadata(metadata)
        return self.recv_updateStreamMetadata()

    def send_updateStreamMetadata(self, metadata):
        self._oprot.writeMessageBegin('updateStreamMetadata', TMessageType.CALL, self._seqid)
        args = updateStreamMetadata_args()
        args.metadata = metadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateStreamMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateStreamMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateStreamMetadata failed: unknown result")

    def open(self, streamId, clientId, expectedLease, setLease):
        """
        Parameters:
         - streamId
         - clientId
         - expectedLease
         - setLease
        """
        self.send_open(streamId, clientId, expectedLease, setLease)
        return self.recv_open()

    def send_open(self, streamId, clientId, expectedLease, setLease):
        self._oprot.writeMessageBegin('open', TMessageType.CALL, self._seqid)
        args = open_args()
        args.streamId = streamId
        args.clientId = clientId
        args.expectedLease = expectedLease
        args.setLease = setLease
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_open(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = open_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "open failed: unknown result")

    def putNext(self, mbMetadata, data, preference, metaKeyValueMap):
        """
        Parameters:
         - mbMetadata
         - data
         - preference
         - metaKeyValueMap
        """
        self.send_putNext(mbMetadata, data, preference, metaKeyValueMap)
        return self.recv_putNext()

    def send_putNext(self, mbMetadata, data, preference, metaKeyValueMap):
        self._oprot.writeMessageBegin('putNext', TMessageType.CALL, self._seqid)
        args = putNext_args()
        args.mbMetadata = mbMetadata
        args.data = data
        args.preference = preference
        args.metaKeyValueMap = metaKeyValueMap
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_putNext(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = putNext_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "putNext failed: unknown result")

    def incrementBlockCount(self, mbMetadata, setLease):
        """
        Parameters:
         - mbMetadata
         - setLease
        """
        self.send_incrementBlockCount(mbMetadata, setLease)
        return self.recv_incrementBlockCount()

    def send_incrementBlockCount(self, mbMetadata, setLease):
        self._oprot.writeMessageBegin('incrementBlockCount', TMessageType.CALL, self._seqid)
        args = incrementBlockCount_args()
        args.mbMetadata = mbMetadata
        args.setLease = setLease
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_incrementBlockCount(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = incrementBlockCount_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "incrementBlockCount failed: unknown result")

    def renewLease(self, streamId, clientId, sessionSecret, expectedLease, setLease):
        """
        Parameters:
         - streamId
         - clientId
         - sessionSecret
         - expectedLease
         - setLease
        """
        self.send_renewLease(streamId, clientId, sessionSecret, expectedLease, setLease)
        return self.recv_renewLease()

    def send_renewLease(self, streamId, clientId, sessionSecret, expectedLease, setLease):
        self._oprot.writeMessageBegin('renewLease', TMessageType.CALL, self._seqid)
        args = renewLease_args()
        args.streamId = streamId
        args.clientId = clientId
        args.sessionSecret = sessionSecret
        args.expectedLease = expectedLease
        args.setLease = setLease
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_renewLease(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = renewLease_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "renewLease failed: unknown result")

    def getLargestBlockId(self, streamId):
        """
        Parameters:
         - streamId
        """
        self.send_getLargestBlockId(streamId)
        return self.recv_getLargestBlockId()

    def send_getLargestBlockId(self, streamId):
        self._oprot.writeMessageBegin('getLargestBlockId', TMessageType.CALL, self._seqid)
        args = getLargestBlockId_args()
        args.streamId = streamId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getLargestBlockId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getLargestBlockId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getLargestBlockId failed: unknown result")

    def findStream(self, squery):
        """
        Parameters:
         - squery
        """
        self.send_findStream(squery)
        return self.recv_findStream()

    def send_findStream(self, squery):
        self._oprot.writeMessageBegin('findStream', TMessageType.CALL, self._seqid)
        args = findStream_args()
        args.squery = squery
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findStream(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findStream_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findStream failed: unknown result")

    def updateBlock(self, mbId, mbMetadata, mbData):
        """
        Parameters:
         - mbId
         - mbMetadata
         - mbData
        """
        self.send_updateBlock(mbId, mbMetadata, mbData)
        return self.recv_updateBlock()

    def send_updateBlock(self, mbId, mbMetadata, mbData):
        self._oprot.writeMessageBegin('updateBlock', TMessageType.CALL, self._seqid)
        args = updateBlock_args()
        args.mbId = mbId
        args.mbMetadata = mbMetadata
        args.mbData = mbData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_updateBlock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = updateBlock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "updateBlock failed: unknown result")

    def listLocalPartitionMbId(self, flag):
        """
        Parameters:
         - flag
        """
        self.send_listLocalPartitionMbId(flag)
        return self.recv_listLocalPartitionMbId()

    def send_listLocalPartitionMbId(self, flag):
        self._oprot.writeMessageBegin('listLocalPartitionMbId', TMessageType.CALL, self._seqid)
        args = listLocalPartitionMbId_args()
        args.flag = flag
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_listLocalPartitionMbId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = listLocalPartitionMbId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "listLocalPartitionMbId failed: unknown result")

    def requestAllNeighbors(self):
        self.send_requestAllNeighbors()
        return self.recv_requestAllNeighbors()

    def send_requestAllNeighbors(self):
        self._oprot.writeMessageBegin('requestAllNeighbors', TMessageType.CALL, self._seqid)
        args = requestAllNeighbors_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_requestAllNeighbors(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = requestAllNeighbors_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "requestAllNeighbors failed: unknown result")

    def requestEdgeMicrobatchMap(self):
        self.send_requestEdgeMicrobatchMap()
        return self.recv_requestEdgeMicrobatchMap()

    def send_requestEdgeMicrobatchMap(self):
        self._oprot.writeMessageBegin('requestEdgeMicrobatchMap', TMessageType.CALL, self._seqid)
        args = requestEdgeMicrobatchMap_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_requestEdgeMicrobatchMap(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = requestEdgeMicrobatchMap_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "requestEdgeMicrobatchMap failed: unknown result")

    def requestCompFormatSize(self, mbId):
        """
        Parameters:
         - mbId
        """
        self.send_requestCompFormatSize(mbId)
        return self.recv_requestCompFormatSize()

    def send_requestCompFormatSize(self, mbId):
        self._oprot.writeMessageBegin('requestCompFormatSize', TMessageType.CALL, self._seqid)
        args = requestCompFormatSize_args()
        args.mbId = mbId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_requestCompFormatSize(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = requestCompFormatSize_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "requestCompFormatSize failed: unknown result")

    def findStreamUsingQuery(self, metaKeyValueMap, checkNeighbors, checkBuddies):
        """
        Parameters:
         - metaKeyValueMap
         - checkNeighbors
         - checkBuddies
        """
        self.send_findStreamUsingQuery(metaKeyValueMap, checkNeighbors, checkBuddies)
        return self.recv_findStreamUsingQuery()

    def send_findStreamUsingQuery(self, metaKeyValueMap, checkNeighbors, checkBuddies):
        self._oprot.writeMessageBegin('findStreamUsingQuery', TMessageType.CALL, self._seqid)
        args = findStreamUsingQuery_args()
        args.metaKeyValueMap = metaKeyValueMap
        args.checkNeighbors = checkNeighbors
        args.checkBuddies = checkBuddies
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findStreamUsingQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findStreamUsingQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findStreamUsingQuery failed: unknown result")

    def findBlockUsingQuery(self, metaKeyValueMap, checkNeighbors, checkBuddies, matchpreference):
        """
        Parameters:
         - metaKeyValueMap
         - checkNeighbors
         - checkBuddies
         - matchpreference
        """
        self.send_findBlockUsingQuery(metaKeyValueMap, checkNeighbors, checkBuddies, matchpreference)
        return self.recv_findBlockUsingQuery()

    def send_findBlockUsingQuery(self, metaKeyValueMap, checkNeighbors, checkBuddies, matchpreference):
        self._oprot.writeMessageBegin('findBlockUsingQuery', TMessageType.CALL, self._seqid)
        args = findBlockUsingQuery_args()
        args.metaKeyValueMap = metaKeyValueMap
        args.checkNeighbors = checkNeighbors
        args.checkBuddies = checkBuddies
        args.matchpreference = matchpreference
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findBlockUsingQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findBlockUsingQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findBlockUsingQuery failed: unknown result")

    def findBlocksAndLocationsWithQuery(self, checkNeighbors, checkBuddies, queryCondition, replicacount, edgeInfo):
        """
        Parameters:
         - checkNeighbors
         - checkBuddies
         - queryCondition
         - replicacount
         - edgeInfo
        """
        self.send_findBlocksAndLocationsWithQuery(checkNeighbors, checkBuddies, queryCondition, replicacount, edgeInfo)
        return self.recv_findBlocksAndLocationsWithQuery()

    def send_findBlocksAndLocationsWithQuery(self, checkNeighbors, checkBuddies, queryCondition, replicacount, edgeInfo):
        self._oprot.writeMessageBegin('findBlocksAndLocationsWithQuery', TMessageType.CALL, self._seqid)
        args = findBlocksAndLocationsWithQuery_args()
        args.checkNeighbors = checkNeighbors
        args.checkBuddies = checkBuddies
        args.queryCondition = queryCondition
        args.replicacount = replicacount
        args.edgeInfo = edgeInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findBlocksAndLocationsWithQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findBlocksAndLocationsWithQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findBlocksAndLocationsWithQuery failed: unknown result")

    def getMetadataByBlockid(self, mbid, fogip, fogport, edgeInfoData, keys):
        """
        Parameters:
         - mbid
         - fogip
         - fogport
         - edgeInfoData
         - keys
        """
        self.send_getMetadataByBlockid(mbid, fogip, fogport, edgeInfoData, keys)
        return self.recv_getMetadataByBlockid()

    def send_getMetadataByBlockid(self, mbid, fogip, fogport, edgeInfoData, keys):
        self._oprot.writeMessageBegin('getMetadataByBlockid', TMessageType.CALL, self._seqid)
        args = getMetadataByBlockid_args()
        args.mbid = mbid
        args.fogip = fogip
        args.fogport = fogport
        args.edgeInfoData = edgeInfoData
        args.keys = keys
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMetadataByBlockid(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMetadataByBlockid_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMetadataByBlockid failed: unknown result")

    def getManyMetadataByBlockidList(self, mbidList, fogip, fogport, edgeInfoData, keys):
        """
        Parameters:
         - mbidList
         - fogip
         - fogport
         - edgeInfoData
         - keys
        """
        self.send_getManyMetadataByBlockidList(mbidList, fogip, fogport, edgeInfoData, keys)
        return self.recv_getManyMetadataByBlockidList()

    def send_getManyMetadataByBlockidList(self, mbidList, fogip, fogport, edgeInfoData, keys):
        self._oprot.writeMessageBegin('getManyMetadataByBlockidList', TMessageType.CALL, self._seqid)
        args = getManyMetadataByBlockidList_args()
        args.mbidList = mbidList
        args.fogip = fogip
        args.fogport = fogport
        args.edgeInfoData = edgeInfoData
        args.keys = keys
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getManyMetadataByBlockidList(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getManyMetadataByBlockidList_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getManyMetadataByBlockidList failed: unknown result")

    def putData(self, mbMetadata, version, data, preference, metaKeyValueMap, clientId):
        """
        Parameters:
         - mbMetadata
         - version
         - data
         - preference
         - metaKeyValueMap
         - clientId
        """
        self.send_putData(mbMetadata, version, data, preference, metaKeyValueMap, clientId)
        return self.recv_putData()

    def send_putData(self, mbMetadata, version, data, preference, metaKeyValueMap, clientId):
        self._oprot.writeMessageBegin('putData', TMessageType.CALL, self._seqid)
        args = putData_args()
        args.mbMetadata = mbMetadata
        args.version = version
        args.data = data
        args.preference = preference
        args.metaKeyValueMap = metaKeyValueMap
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_putData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = putData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "putData failed: unknown result")

    def putDataQuorum(self, mbMetadata, version, data, metaKeyValueMap, clientid):
        """
        Parameters:
         - mbMetadata
         - version
         - data
         - metaKeyValueMap
         - clientid
        """
        self.send_putDataQuorum(mbMetadata, version, data, metaKeyValueMap, clientid)
        return self.recv_putDataQuorum()

    def send_putDataQuorum(self, mbMetadata, version, data, metaKeyValueMap, clientid):
        self._oprot.writeMessageBegin('putDataQuorum', TMessageType.CALL, self._seqid)
        args = putDataQuorum_args()
        args.mbMetadata = mbMetadata
        args.version = version
        args.data = data
        args.metaKeyValueMap = metaKeyValueMap
        args.clientid = clientid
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_putDataQuorum(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = putDataQuorum_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "putDataQuorum failed: unknown result")

    def get(self, microbatchId, fetchMetadata, compFormat, uncompSize, clientId):
        """
        Parameters:
         - microbatchId
         - fetchMetadata
         - compFormat
         - uncompSize
         - clientId
        """
        self.send_get(microbatchId, fetchMetadata, compFormat, uncompSize, clientId)
        return self.recv_get()

    def send_get(self, microbatchId, fetchMetadata, compFormat, uncompSize, clientId):
        self._oprot.writeMessageBegin('get', TMessageType.CALL, self._seqid)
        args = get_args()
        args.microbatchId = microbatchId
        args.fetchMetadata = fetchMetadata
        args.compFormat = compFormat
        args.uncompSize = uncompSize
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result")

    def getData(self, microbatchId, fetchMetadata, compFormat, uncompSize, selfInfo):
        """
        Parameters:
         - microbatchId
         - fetchMetadata
         - compFormat
         - uncompSize
         - selfInfo
        """
        self.send_getData(microbatchId, fetchMetadata, compFormat, uncompSize, selfInfo)
        return self.recv_getData()

    def send_getData(self, microbatchId, fetchMetadata, compFormat, uncompSize, selfInfo):
        self._oprot.writeMessageBegin('getData', TMessageType.CALL, self._seqid)
        args = getData_args()
        args.microbatchId = microbatchId
        args.fetchMetadata = fetchMetadata
        args.compFormat = compFormat
        args.uncompSize = uncompSize
        args.selfInfo = selfInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getData(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getData_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getData failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["joinCluster"] = Processor.process_joinCluster
        self._processMap["joinPool"] = Processor.process_joinPool
        self._processMap["getCandidatePool"] = Processor.process_getCandidatePool
        self._processMap["bootstrapFog"] = Processor.process_bootstrapFog
        self._processMap["initiate2PhasePreCommit"] = Processor.process_initiate2PhasePreCommit
        self._processMap["initiate2PhaseCommit"] = Processor.process_initiate2PhaseCommit
        self._processMap["buddyHeartBeat"] = Processor.process_buddyHeartBeat
        self._processMap["neighborHeartBeat"] = Processor.process_neighborHeartBeat
        self._processMap["getPoolMember"] = Processor.process_getPoolMember
        self._processMap["getBuddyPoolMembers"] = Processor.process_getBuddyPoolMembers
        self._processMap["getNeighborCountPerPool"] = Processor.process_getNeighborCountPerPool
        self._processMap["requestNeighbors"] = Processor.process_requestNeighbors
        self._processMap["nodeJoiningComplete"] = Processor.process_nodeJoiningComplete
        self._processMap["subscribe"] = Processor.process_subscribe
        self._processMap["edgeHeartBeats"] = Processor.process_edgeHeartBeats
        self._processMap["edgeJoin"] = Processor.process_edgeJoin
        self._processMap["edgeLeave"] = Processor.process_edgeLeave
        self._processMap["terminate"] = Processor.process_terminate
        self._processMap["registerStream"] = Processor.process_registerStream
        self._processMap["intentToWrite"] = Processor.process_intentToWrite
        self._processMap["getStreamMetadata"] = Processor.process_getStreamMetadata
        self._processMap["getStreamMetadataFromOwner"] = Processor.process_getStreamMetadataFromOwner
        self._processMap["getWriteLocations"] = Processor.process_getWriteLocations
        self._processMap["write"] = Processor.process_write
        self._processMap["writeNext"] = Processor.process_writeNext
        self._processMap["insertMetadata"] = Processor.process_insertMetadata
        self._processMap["findNext"] = Processor.process_findNext
        self._processMap["find"] = Processor.process_find
        self._processMap["findFast"] = Processor.process_findFast
        self._processMap["read"] = Processor.process_read
        self._processMap["findUsingQuery"] = Processor.process_findUsingQuery
        self._processMap["getMeta"] = Processor.process_getMeta
        self._processMap["serializeState"] = Processor.process_serializeState
        self._processMap["updateStreamMetadata"] = Processor.process_updateStreamMetadata
        self._processMap["open"] = Processor.process_open
        self._processMap["putNext"] = Processor.process_putNext
        self._processMap["incrementBlockCount"] = Processor.process_incrementBlockCount
        self._processMap["renewLease"] = Processor.process_renewLease
        self._processMap["getLargestBlockId"] = Processor.process_getLargestBlockId
        self._processMap["findStream"] = Processor.process_findStream
        self._processMap["updateBlock"] = Processor.process_updateBlock
        self._processMap["listLocalPartitionMbId"] = Processor.process_listLocalPartitionMbId
        self._processMap["requestAllNeighbors"] = Processor.process_requestAllNeighbors
        self._processMap["requestEdgeMicrobatchMap"] = Processor.process_requestEdgeMicrobatchMap
        self._processMap["requestCompFormatSize"] = Processor.process_requestCompFormatSize
        self._processMap["findStreamUsingQuery"] = Processor.process_findStreamUsingQuery
        self._processMap["findBlockUsingQuery"] = Processor.process_findBlockUsingQuery
        self._processMap["findBlocksAndLocationsWithQuery"] = Processor.process_findBlocksAndLocationsWithQuery
        self._processMap["getMetadataByBlockid"] = Processor.process_getMetadataByBlockid
        self._processMap["getManyMetadataByBlockidList"] = Processor.process_getManyMetadataByBlockidList
        self._processMap["putData"] = Processor.process_putData
        self._processMap["putDataQuorum"] = Processor.process_putDataQuorum
        self._processMap["get"] = Processor.process_get
        self._processMap["getData"] = Processor.process_getData

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_joinCluster(self, seqid, iprot, oprot):
        args = joinCluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = joinCluster_result()
        try:
            result.success = self._handler.joinCluster(args.NodeX, args.pmin, args.pmax)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("joinCluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_joinPool(self, seqid, iprot, oprot):
        args = joinPool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = joinPool_result()
        try:
            result.success = self._handler.joinPool(args.NodeX)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("joinPool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCandidatePool(self, seqid, iprot, oprot):
        args = getCandidatePool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCandidatePool_result()
        try:
            result.success = self._handler.getCandidatePool(args.reliability, args.pmin)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCandidatePool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_bootstrapFog(self, seqid, iprot, oprot):
        args = bootstrapFog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = bootstrapFog_result()
        try:
            result.success = self._handler.bootstrapFog(args.NodeX)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("bootstrapFog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_initiate2PhasePreCommit(self, seqid, iprot, oprot):
        args = initiate2PhasePreCommit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = initiate2PhasePreCommit_result()
        try:
            result.success = self._handler.initiate2PhasePreCommit(args.preCommitRequest)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("initiate2PhasePreCommit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_initiate2PhaseCommit(self, seqid, iprot, oprot):
        args = initiate2PhaseCommit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = initiate2PhaseCommit_result()
        try:
            result.success = self._handler.initiate2PhaseCommit(args.commitRequest)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("initiate2PhaseCommit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_buddyHeartBeat(self, seqid, iprot, oprot):
        args = buddyHeartBeat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.buddyHeartBeat(args.payload)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_neighborHeartBeat(self, seqid, iprot, oprot):
        args = neighborHeartBeat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.neighborHeartBeat(args.payload)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_getPoolMember(self, seqid, iprot, oprot):
        args = getPoolMember_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPoolMember_result()
        try:
            result.success = self._handler.getPoolMember(args.buddyPoolId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPoolMember", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getBuddyPoolMembers(self, seqid, iprot, oprot):
        args = getBuddyPoolMembers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getBuddyPoolMembers_result()
        try:
            result.success = self._handler.getBuddyPoolMembers()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getBuddyPoolMembers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNeighborCountPerPool(self, seqid, iprot, oprot):
        args = getNeighborCountPerPool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNeighborCountPerPool_result()
        try:
            result.success = self._handler.getNeighborCountPerPool()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNeighborCountPerPool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_requestNeighbors(self, seqid, iprot, oprot):
        args = requestNeighbors_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestNeighbors_result()
        try:
            result.success = self._handler.requestNeighbors(args.requestMap)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("requestNeighbors", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_nodeJoiningComplete(self, seqid, iprot, oprot):
        args = nodeJoiningComplete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = nodeJoiningComplete_result()
        try:
            self._handler.nodeJoiningComplete()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("nodeJoiningComplete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_subscribe(self, seqid, iprot, oprot):
        args = subscribe_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = subscribe_result()
        try:
            result.success = self._handler.subscribe(args.nodeInfoData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("subscribe", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_edgeHeartBeats(self, seqid, iprot, oprot):
        args = edgeHeartBeats_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = edgeHeartBeats_result()
        try:
            result.success = self._handler.edgeHeartBeats(args.edgePayload)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("edgeHeartBeats", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_edgeJoin(self, seqid, iprot, oprot):
        args = edgeJoin_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = edgeJoin_result()
        try:
            result.success = self._handler.edgeJoin(args.edgeInfoData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("edgeJoin", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_edgeLeave(self, seqid, iprot, oprot):
        args = edgeLeave_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = edgeLeave_result()
        try:
            result.success = self._handler.edgeLeave(args.edgeInfoData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("edgeLeave", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_terminate(self, seqid, iprot, oprot):
        args = terminate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = terminate_result()
        try:
            result.success = self._handler.terminate(args.streamId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("terminate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_registerStream(self, seqid, iprot, oprot):
        args = registerStream_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerStream_result()
        try:
            result.success = self._handler.registerStream(args.streamId, args.streamMetadata, args.startSequenceNumber)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("registerStream", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_intentToWrite(self, seqid, iprot, oprot):
        args = intentToWrite_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = intentToWrite_result()
        try:
            result.success = self._handler.intentToWrite(args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("intentToWrite", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getStreamMetadata(self, seqid, iprot, oprot):
        args = getStreamMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getStreamMetadata_result()
        try:
            result.success = self._handler.getStreamMetadata(args.streamId, args.checkNeighbors, args.checkBuddies, args.forceLatest)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getStreamMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getStreamMetadataFromOwner(self, seqid, iprot, oprot):
        args = getStreamMetadataFromOwner_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getStreamMetadataFromOwner_result()
        try:
            result.success = self._handler.getStreamMetadataFromOwner(args.streamId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getStreamMetadataFromOwner", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getWriteLocations(self, seqid, iprot, oprot):
        args = getWriteLocations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getWriteLocations_result()
        try:
            result.success = self._handler.getWriteLocations(args.dataLength, args.metadata, args.blackListedFogs, args.isEdge)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getWriteLocations", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write(self, seqid, iprot, oprot):
        args = write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_result()
        try:
            result.success = self._handler.write(args.mbMetadata, args.data, args.preference)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_writeNext(self, seqid, iprot, oprot):
        args = writeNext_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = writeNext_result()
        try:
            result.success = self._handler.writeNext(args.sessionId, args.mbData, args.dataLength)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("writeNext", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_insertMetadata(self, seqid, iprot, oprot):
        args = insertMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = insertMetadata_result()
        try:
            result.success = self._handler.insertMetadata(args.mbMetadata, args.edgeInfoData, args.metaKeyValueMap)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("insertMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findNext(self, seqid, iprot, oprot):
        args = findNext_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findNext_result()
        try:
            result.success = self._handler.findNext(args.microbatchId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findNext", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_find(self, seqid, iprot, oprot):
        args = find_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = find_result()
        try:
            result.success = self._handler.find(args.microbatchId, args.checkNeighbors, args.checkBuddies, args.selfInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("find", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findFast(self, seqid, iprot, oprot):
        args = findFast_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findFast_result()
        try:
            result.success = self._handler.findFast(args.microbatchIdList, args.checkNeighbors, args.checkBuddies, args.selfInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findFast", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read(self, seqid, iprot, oprot):
        args = read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_result()
        try:
            result.success = self._handler.read(args.microbatchId, args.fetchMetadata, args.compFormat, args.uncompSize)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findUsingQuery(self, seqid, iprot, oprot):
        args = findUsingQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findUsingQuery_result()
        try:
            result.success = self._handler.findUsingQuery(args.metadataKey, args.metadataValue, args.checkNeighbors, args.checkBuddies)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findUsingQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMeta(self, seqid, iprot, oprot):
        args = getMeta_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMeta_result()
        try:
            result.success = self._handler.getMeta(args.microbatchId, args.checkNeighbors, args.checkBuddies)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMeta", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_serializeState(self, seqid, iprot, oprot):
        args = serializeState_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = serializeState_result()
        try:
            result.success = self._handler.serializeState()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("serializeState", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateStreamMetadata(self, seqid, iprot, oprot):
        args = updateStreamMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateStreamMetadata_result()
        try:
            result.success = self._handler.updateStreamMetadata(args.metadata)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateStreamMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_open(self, seqid, iprot, oprot):
        args = open_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = open_result()
        try:
            result.success = self._handler.open(args.streamId, args.clientId, args.expectedLease, args.setLease)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("open", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_putNext(self, seqid, iprot, oprot):
        args = putNext_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = putNext_result()
        try:
            result.success = self._handler.putNext(args.mbMetadata, args.data, args.preference, args.metaKeyValueMap)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("putNext", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_incrementBlockCount(self, seqid, iprot, oprot):
        args = incrementBlockCount_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = incrementBlockCount_result()
        try:
            result.success = self._handler.incrementBlockCount(args.mbMetadata, args.setLease)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("incrementBlockCount", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_renewLease(self, seqid, iprot, oprot):
        args = renewLease_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = renewLease_result()
        try:
            result.success = self._handler.renewLease(args.streamId, args.clientId, args.sessionSecret, args.expectedLease, args.setLease)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("renewLease", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getLargestBlockId(self, seqid, iprot, oprot):
        args = getLargestBlockId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getLargestBlockId_result()
        try:
            result.success = self._handler.getLargestBlockId(args.streamId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getLargestBlockId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findStream(self, seqid, iprot, oprot):
        args = findStream_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findStream_result()
        try:
            result.success = self._handler.findStream(args.squery)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findStream", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_updateBlock(self, seqid, iprot, oprot):
        args = updateBlock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = updateBlock_result()
        try:
            result.success = self._handler.updateBlock(args.mbId, args.mbMetadata, args.mbData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("updateBlock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_listLocalPartitionMbId(self, seqid, iprot, oprot):
        args = listLocalPartitionMbId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = listLocalPartitionMbId_result()
        try:
            result.success = self._handler.listLocalPartitionMbId(args.flag)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("listLocalPartitionMbId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_requestAllNeighbors(self, seqid, iprot, oprot):
        args = requestAllNeighbors_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestAllNeighbors_result()
        try:
            result.success = self._handler.requestAllNeighbors()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("requestAllNeighbors", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_requestEdgeMicrobatchMap(self, seqid, iprot, oprot):
        args = requestEdgeMicrobatchMap_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestEdgeMicrobatchMap_result()
        try:
            result.success = self._handler.requestEdgeMicrobatchMap()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("requestEdgeMicrobatchMap", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_requestCompFormatSize(self, seqid, iprot, oprot):
        args = requestCompFormatSize_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestCompFormatSize_result()
        try:
            result.success = self._handler.requestCompFormatSize(args.mbId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("requestCompFormatSize", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findStreamUsingQuery(self, seqid, iprot, oprot):
        args = findStreamUsingQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findStreamUsingQuery_result()
        try:
            result.success = self._handler.findStreamUsingQuery(args.metaKeyValueMap, args.checkNeighbors, args.checkBuddies)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findStreamUsingQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findBlockUsingQuery(self, seqid, iprot, oprot):
        args = findBlockUsingQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findBlockUsingQuery_result()
        try:
            result.success = self._handler.findBlockUsingQuery(args.metaKeyValueMap, args.checkNeighbors, args.checkBuddies, args.matchpreference)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findBlockUsingQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findBlocksAndLocationsWithQuery(self, seqid, iprot, oprot):
        args = findBlocksAndLocationsWithQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findBlocksAndLocationsWithQuery_result()
        try:
            result.success = self._handler.findBlocksAndLocationsWithQuery(args.checkNeighbors, args.checkBuddies, args.queryCondition, args.replicacount, args.edgeInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findBlocksAndLocationsWithQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getMetadataByBlockid(self, seqid, iprot, oprot):
        args = getMetadataByBlockid_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMetadataByBlockid_result()
        try:
            result.success = self._handler.getMetadataByBlockid(args.mbid, args.fogip, args.fogport, args.edgeInfoData, args.keys)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMetadataByBlockid", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getManyMetadataByBlockidList(self, seqid, iprot, oprot):
        args = getManyMetadataByBlockidList_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getManyMetadataByBlockidList_result()
        try:
            result.success = self._handler.getManyMetadataByBlockidList(args.mbidList, args.fogip, args.fogport, args.edgeInfoData, args.keys)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getManyMetadataByBlockidList", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_putData(self, seqid, iprot, oprot):
        args = putData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = putData_result()
        try:
            result.success = self._handler.putData(args.mbMetadata, args.version, args.data, args.preference, args.metaKeyValueMap, args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("putData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_putDataQuorum(self, seqid, iprot, oprot):
        args = putDataQuorum_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = putDataQuorum_result()
        try:
            result.success = self._handler.putDataQuorum(args.mbMetadata, args.version, args.data, args.metaKeyValueMap, args.clientid)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("putDataQuorum", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get(self, seqid, iprot, oprot):
        args = get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_result()
        try:
            result.success = self._handler.get(args.microbatchId, args.fetchMetadata, args.compFormat, args.uncompSize, args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getData(self, seqid, iprot, oprot):
        args = getData_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getData_result()
        try:
            result.success = self._handler.getData(args.microbatchId, args.fetchMetadata, args.compFormat, args.uncompSize, args.selfInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getData", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class joinCluster_args(object):
    """
    Attributes:
     - NodeX
     - pmin
     - pmax
    """


    def __init__(self, NodeX=None, pmin=None, pmax=None,):
        self.NodeX = NodeX
        self.pmin = pmin
        self.pmax = pmax

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.NodeX = FogInfoData()
                    self.NodeX.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.pmin = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.pmax = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('joinCluster_args')
        if self.NodeX is not None:
            oprot.writeFieldBegin('NodeX', TType.STRUCT, 1)
            self.NodeX.write(oprot)
            oprot.writeFieldEnd()
        if self.pmin is not None:
            oprot.writeFieldBegin('pmin', TType.I16, 2)
            oprot.writeI16(self.pmin)
            oprot.writeFieldEnd()
        if self.pmax is not None:
            oprot.writeFieldBegin('pmax', TType.I16, 3)
            oprot.writeI16(self.pmax)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(joinCluster_args)
joinCluster_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'NodeX', [FogInfoData, None], None, ),  # 1
    (2, TType.I16, 'pmin', None, None, ),  # 2
    (3, TType.I16, 'pmax', None, None, ),  # 3
)


class joinCluster_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype133, _size130) = iprot.readListBegin()
                    for _i134 in range(_size130):
                        _elem135 = NeighborInfoData()
                        _elem135.read(iprot)
                        self.success.append(_elem135)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('joinCluster_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter136 in self.success:
                iter136.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(joinCluster_result)
joinCluster_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [NeighborInfoData, None], False), None, ),  # 0
)


class joinPool_args(object):
    """
    Attributes:
     - NodeX
    """


    def __init__(self, NodeX=None,):
        self.NodeX = NodeX

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.NodeX = FogInfoData()
                    self.NodeX.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('joinPool_args')
        if self.NodeX is not None:
            oprot.writeFieldBegin('NodeX', TType.STRUCT, 1)
            self.NodeX.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(joinPool_args)
joinPool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'NodeX', [FogInfoData, None], None, ),  # 1
)


class joinPool_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TwoPhaseCommitResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('joinPool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(joinPool_result)
joinPool_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TwoPhaseCommitResponse, None], None, ),  # 0
)


class getCandidatePool_args(object):
    """
    Attributes:
     - reliability
     - pmin
    """


    def __init__(self, reliability=None, pmin=None,):
        self.reliability = reliability
        self.pmin = pmin

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.reliability = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.pmin = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCandidatePool_args')
        if self.reliability is not None:
            oprot.writeFieldBegin('reliability', TType.DOUBLE, 1)
            oprot.writeDouble(self.reliability)
            oprot.writeFieldEnd()
        if self.pmin is not None:
            oprot.writeFieldBegin('pmin', TType.I16, 2)
            oprot.writeI16(self.pmin)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCandidatePool_args)
getCandidatePool_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'reliability', None, None, ),  # 1
    (2, TType.I16, 'pmin', None, None, ),  # 2
)


class getCandidatePool_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype140, _size137) = iprot.readListBegin()
                    for _i141 in range(_size137):
                        _elem142 = NeighborInfoData()
                        _elem142.read(iprot)
                        self.success.append(_elem142)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCandidatePool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter143 in self.success:
                iter143.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCandidatePool_result)
getCandidatePool_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [NeighborInfoData, None], False), None, ),  # 0
)


class bootstrapFog_args(object):
    """
    Attributes:
     - NodeX
    """


    def __init__(self, NodeX=None,):
        self.NodeX = NodeX

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.NodeX = FogInfoData()
                    self.NodeX.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('bootstrapFog_args')
        if self.NodeX is not None:
            oprot.writeFieldBegin('NodeX', TType.STRUCT, 1)
            self.NodeX.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(bootstrapFog_args)
bootstrapFog_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'NodeX', [FogInfoData, None], None, ),  # 1
)


class bootstrapFog_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('bootstrapFog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(bootstrapFog_result)
bootstrapFog_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class initiate2PhasePreCommit_args(object):
    """
    Attributes:
     - preCommitRequest
    """


    def __init__(self, preCommitRequest=None,):
        self.preCommitRequest = preCommitRequest

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.preCommitRequest = TwoPhasePreCommitRequest()
                    self.preCommitRequest.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initiate2PhasePreCommit_args')
        if self.preCommitRequest is not None:
            oprot.writeFieldBegin('preCommitRequest', TType.STRUCT, 1)
            self.preCommitRequest.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initiate2PhasePreCommit_args)
initiate2PhasePreCommit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'preCommitRequest', [TwoPhasePreCommitRequest, None], None, ),  # 1
)


class initiate2PhasePreCommit_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TwoPhasePreCommitResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initiate2PhasePreCommit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initiate2PhasePreCommit_result)
initiate2PhasePreCommit_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TwoPhasePreCommitResponse, None], None, ),  # 0
)


class initiate2PhaseCommit_args(object):
    """
    Attributes:
     - commitRequest
    """


    def __init__(self, commitRequest=None,):
        self.commitRequest = commitRequest

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.commitRequest = TwoPhaseCommitRequest()
                    self.commitRequest.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initiate2PhaseCommit_args')
        if self.commitRequest is not None:
            oprot.writeFieldBegin('commitRequest', TType.STRUCT, 1)
            self.commitRequest.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initiate2PhaseCommit_args)
initiate2PhaseCommit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'commitRequest', [TwoPhaseCommitRequest, None], None, ),  # 1
)


class initiate2PhaseCommit_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TwoPhaseCommitResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initiate2PhaseCommit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initiate2PhaseCommit_result)
initiate2PhaseCommit_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TwoPhaseCommitResponse, None], None, ),  # 0
)


class buddyHeartBeat_args(object):
    """
    Attributes:
     - payload
    """


    def __init__(self, payload=None,):
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.payload = BuddyPayload()
                    self.payload.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('buddyHeartBeat_args')
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRUCT, 1)
            self.payload.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(buddyHeartBeat_args)
buddyHeartBeat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'payload', [BuddyPayload, None], None, ),  # 1
)


class neighborHeartBeat_args(object):
    """
    Attributes:
     - payload
    """


    def __init__(self, payload=None,):
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.payload = NeighborPayload()
                    self.payload.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('neighborHeartBeat_args')
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRUCT, 1)
            self.payload.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(neighborHeartBeat_args)
neighborHeartBeat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'payload', [NeighborPayload, None], None, ),  # 1
)


class getPoolMember_args(object):
    """
    Attributes:
     - buddyPoolId
    """


    def __init__(self, buddyPoolId=None,):
        self.buddyPoolId = buddyPoolId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.buddyPoolId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPoolMember_args')
        if self.buddyPoolId is not None:
            oprot.writeFieldBegin('buddyPoolId', TType.I16, 1)
            oprot.writeI16(self.buddyPoolId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPoolMember_args)
getPoolMember_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'buddyPoolId', None, None, ),  # 1
)


class getPoolMember_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NodeInfoData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPoolMember_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPoolMember_result)
getPoolMember_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NodeInfoData, None], None, ),  # 0
)


class getBuddyPoolMembers_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBuddyPoolMembers_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBuddyPoolMembers_args)
getBuddyPoolMembers_args.thrift_spec = (
)


class getBuddyPoolMembers_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype147, _size144) = iprot.readListBegin()
                    for _i148 in range(_size144):
                        _elem149 = FogInfoData()
                        _elem149.read(iprot)
                        self.success.append(_elem149)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBuddyPoolMembers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter150 in self.success:
                iter150.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBuddyPoolMembers_result)
getBuddyPoolMembers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [FogInfoData, None], False), None, ),  # 0
)


class getNeighborCountPerPool_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNeighborCountPerPool_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNeighborCountPerPool_args)
getNeighborCountPerPool_args.thrift_spec = (
)


class getNeighborCountPerPool_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NeighborCount()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNeighborCountPerPool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNeighborCountPerPool_result)
getNeighborCountPerPool_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NeighborCount, None], None, ),  # 0
)


class requestNeighbors_args(object):
    """
    Attributes:
     - requestMap
    """


    def __init__(self, requestMap=None,):
        self.requestMap = requestMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.requestMap = {}
                    (_ktype152, _vtype153, _size151) = iprot.readMapBegin()
                    for _i155 in range(_size151):
                        _key156 = iprot.readI16()
                        _val157 = iprot.readI16()
                        self.requestMap[_key156] = _val157
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestNeighbors_args')
        if self.requestMap is not None:
            oprot.writeFieldBegin('requestMap', TType.MAP, 1)
            oprot.writeMapBegin(TType.I16, TType.I16, len(self.requestMap))
            for kiter158, viter159 in self.requestMap.items():
                oprot.writeI16(kiter158)
                oprot.writeI16(viter159)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestNeighbors_args)
requestNeighbors_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'requestMap', (TType.I16, None, TType.I16, None, False), None, ),  # 1
)


class requestNeighbors_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype163, _size160) = iprot.readListBegin()
                    for _i164 in range(_size160):
                        _elem165 = NeighborInfoData()
                        _elem165.read(iprot)
                        self.success.append(_elem165)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestNeighbors_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter166 in self.success:
                iter166.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestNeighbors_result)
requestNeighbors_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [NeighborInfoData, None], False), None, ),  # 0
)


class nodeJoiningComplete_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nodeJoiningComplete_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nodeJoiningComplete_args)
nodeJoiningComplete_args.thrift_spec = (
)


class nodeJoiningComplete_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nodeJoiningComplete_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nodeJoiningComplete_result)
nodeJoiningComplete_result.thrift_spec = (
)


class subscribe_args(object):
    """
    Attributes:
     - nodeInfoData
    """


    def __init__(self, nodeInfoData=None,):
        self.nodeInfoData = nodeInfoData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.nodeInfoData = NodeInfoData()
                    self.nodeInfoData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('subscribe_args')
        if self.nodeInfoData is not None:
            oprot.writeFieldBegin('nodeInfoData', TType.STRUCT, 1)
            self.nodeInfoData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(subscribe_args)
subscribe_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'nodeInfoData', [NodeInfoData, None], None, ),  # 1
)


class subscribe_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('subscribe_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(subscribe_result)
subscribe_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class edgeHeartBeats_args(object):
    """
    Attributes:
     - edgePayload
    """


    def __init__(self, edgePayload=None,):
        self.edgePayload = edgePayload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.edgePayload = EdgePayload()
                    self.edgePayload.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('edgeHeartBeats_args')
        if self.edgePayload is not None:
            oprot.writeFieldBegin('edgePayload', TType.STRUCT, 1)
            self.edgePayload.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(edgeHeartBeats_args)
edgeHeartBeats_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'edgePayload', [EdgePayload, None], None, ),  # 1
)


class edgeHeartBeats_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('edgeHeartBeats_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(edgeHeartBeats_result)
edgeHeartBeats_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class edgeJoin_args(object):
    """
    Attributes:
     - edgeInfoData
    """


    def __init__(self, edgeInfoData=None,):
        self.edgeInfoData = edgeInfoData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.edgeInfoData = EdgeInfoData()
                    self.edgeInfoData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('edgeJoin_args')
        if self.edgeInfoData is not None:
            oprot.writeFieldBegin('edgeInfoData', TType.STRUCT, 1)
            self.edgeInfoData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(edgeJoin_args)
edgeJoin_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'edgeInfoData', [EdgeInfoData, None], None, ),  # 1
)


class edgeJoin_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('edgeJoin_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(edgeJoin_result)
edgeJoin_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class edgeLeave_args(object):
    """
    Attributes:
     - edgeInfoData
    """


    def __init__(self, edgeInfoData=None,):
        self.edgeInfoData = edgeInfoData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.edgeInfoData = EdgeInfoData()
                    self.edgeInfoData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('edgeLeave_args')
        if self.edgeInfoData is not None:
            oprot.writeFieldBegin('edgeInfoData', TType.STRUCT, 1)
            self.edgeInfoData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(edgeLeave_args)
edgeLeave_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'edgeInfoData', [EdgeInfoData, None], None, ),  # 1
)


class edgeLeave_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('edgeLeave_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(edgeLeave_result)
edgeLeave_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class terminate_args(object):
    """
    Attributes:
     - streamId
    """


    def __init__(self, streamId=None,):
        self.streamId = streamId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.streamId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('terminate_args')
        if self.streamId is not None:
            oprot.writeFieldBegin('streamId', TType.STRING, 1)
            oprot.writeString(self.streamId.encode('utf-8') if sys.version_info[0] == 2 else self.streamId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(terminate_args)
terminate_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'streamId', 'UTF8', None, ),  # 1
)


class terminate_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('terminate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(terminate_result)
terminate_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class registerStream_args(object):
    """
    Attributes:
     - streamId
     - streamMetadata
     - startSequenceNumber
    """


    def __init__(self, streamId=None, streamMetadata=None, startSequenceNumber=None,):
        self.streamId = streamId
        self.streamMetadata = streamMetadata
        self.startSequenceNumber = startSequenceNumber

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.streamId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.streamMetadata = StreamMetadata()
                    self.streamMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startSequenceNumber = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('registerStream_args')
        if self.streamId is not None:
            oprot.writeFieldBegin('streamId', TType.STRING, 1)
            oprot.writeString(self.streamId.encode('utf-8') if sys.version_info[0] == 2 else self.streamId)
            oprot.writeFieldEnd()
        if self.streamMetadata is not None:
            oprot.writeFieldBegin('streamMetadata', TType.STRUCT, 2)
            self.streamMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.startSequenceNumber is not None:
            oprot.writeFieldBegin('startSequenceNumber', TType.I64, 3)
            oprot.writeI64(self.startSequenceNumber)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(registerStream_args)
registerStream_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'streamId', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'streamMetadata', [StreamMetadata, None], None, ),  # 2
    (3, TType.I64, 'startSequenceNumber', None, None, ),  # 3
)


class registerStream_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('registerStream_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(registerStream_result)
registerStream_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class intentToWrite_args(object):
    """
    Attributes:
     - clientId
    """


    def __init__(self, clientId=None,):
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.clientId = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('intentToWrite_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.BYTE, 1)
            oprot.writeByte(self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(intentToWrite_args)
intentToWrite_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'clientId', None, None, ),  # 1
)


class intentToWrite_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('intentToWrite_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(intentToWrite_result)
intentToWrite_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getStreamMetadata_args(object):
    """
    Attributes:
     - streamId
     - checkNeighbors
     - checkBuddies
     - forceLatest
    """


    def __init__(self, streamId=None, checkNeighbors=None, checkBuddies=None, forceLatest=None,):
        self.streamId = streamId
        self.checkNeighbors = checkNeighbors
        self.checkBuddies = checkBuddies
        self.forceLatest = forceLatest

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.streamId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.checkNeighbors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.checkBuddies = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.forceLatest = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getStreamMetadata_args')
        if self.streamId is not None:
            oprot.writeFieldBegin('streamId', TType.STRING, 1)
            oprot.writeString(self.streamId.encode('utf-8') if sys.version_info[0] == 2 else self.streamId)
            oprot.writeFieldEnd()
        if self.checkNeighbors is not None:
            oprot.writeFieldBegin('checkNeighbors', TType.BOOL, 2)
            oprot.writeBool(self.checkNeighbors)
            oprot.writeFieldEnd()
        if self.checkBuddies is not None:
            oprot.writeFieldBegin('checkBuddies', TType.BOOL, 3)
            oprot.writeBool(self.checkBuddies)
            oprot.writeFieldEnd()
        if self.forceLatest is not None:
            oprot.writeFieldBegin('forceLatest', TType.BOOL, 4)
            oprot.writeBool(self.forceLatest)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getStreamMetadata_args)
getStreamMetadata_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'streamId', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'checkNeighbors', None, None, ),  # 2
    (3, TType.BOOL, 'checkBuddies', None, None, ),  # 3
    (4, TType.BOOL, 'forceLatest', None, None, ),  # 4
)


class getStreamMetadata_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StreamMetadataInfo()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getStreamMetadata_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getStreamMetadata_result)
getStreamMetadata_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [StreamMetadataInfo, None], None, ),  # 0
)


class getStreamMetadataFromOwner_args(object):
    """
    Attributes:
     - streamId
    """


    def __init__(self, streamId=None,):
        self.streamId = streamId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.streamId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getStreamMetadataFromOwner_args')
        if self.streamId is not None:
            oprot.writeFieldBegin('streamId', TType.STRING, 1)
            oprot.writeString(self.streamId.encode('utf-8') if sys.version_info[0] == 2 else self.streamId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getStreamMetadataFromOwner_args)
getStreamMetadataFromOwner_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'streamId', 'UTF8', None, ),  # 1
)


class getStreamMetadataFromOwner_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StreamMetadata()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getStreamMetadataFromOwner_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getStreamMetadataFromOwner_result)
getStreamMetadataFromOwner_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [StreamMetadata, None], None, ),  # 0
)


class getWriteLocations_args(object):
    """
    Attributes:
     - dataLength
     - metadata
     - blackListedFogs
     - isEdge
    """


    def __init__(self, dataLength=None, metadata=None, blackListedFogs=None, isEdge=None,):
        self.dataLength = dataLength
        self.metadata = metadata
        self.blackListedFogs = blackListedFogs
        self.isEdge = isEdge

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.dataLength = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metadata = Metadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.blackListedFogs = []
                    (_etype170, _size167) = iprot.readListBegin()
                    for _i171 in range(_size167):
                        _elem172 = iprot.readI16()
                        self.blackListedFogs.append(_elem172)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isEdge = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getWriteLocations_args')
        if self.dataLength is not None:
            oprot.writeFieldBegin('dataLength', TType.BYTE, 1)
            oprot.writeByte(self.dataLength)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.blackListedFogs is not None:
            oprot.writeFieldBegin('blackListedFogs', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.blackListedFogs))
            for iter173 in self.blackListedFogs:
                oprot.writeI16(iter173)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.isEdge is not None:
            oprot.writeFieldBegin('isEdge', TType.BOOL, 4)
            oprot.writeBool(self.isEdge)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getWriteLocations_args)
getWriteLocations_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'dataLength', None, None, ),  # 1
    (2, TType.STRUCT, 'metadata', [Metadata, None], None, ),  # 2
    (3, TType.LIST, 'blackListedFogs', (TType.I16, None, False), None, ),  # 3
    (4, TType.BOOL, 'isEdge', None, None, ),  # 4
)


class getWriteLocations_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype177, _size174) = iprot.readListBegin()
                    for _i178 in range(_size174):
                        _elem179 = WritableFogData()
                        _elem179.read(iprot)
                        self.success.append(_elem179)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getWriteLocations_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter180 in self.success:
                iter180.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getWriteLocations_result)
getWriteLocations_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [WritableFogData, None], False), None, ),  # 0
)


class write_args(object):
    """
    Attributes:
     - mbMetadata
     - data
     - preference
    """


    def __init__(self, mbMetadata=None, data=None, preference=None,):
        self.mbMetadata = mbMetadata
        self.data = data
        self.preference = preference

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.mbMetadata = Metadata()
                    self.mbMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.preference = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_args')
        if self.mbMetadata is not None:
            oprot.writeFieldBegin('mbMetadata', TType.STRUCT, 1)
            self.mbMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 2)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.preference is not None:
            oprot.writeFieldBegin('preference', TType.I32, 3)
            oprot.writeI32(self.preference)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_args)
write_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'mbMetadata', [Metadata, None], None, ),  # 1
    (2, TType.STRING, 'data', 'BINARY', None, ),  # 2
    (3, TType.I32, 'preference', None, None, ),  # 3
)


class write_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WriteResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_result)
write_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [WriteResponse, None], None, ),  # 0
)


class writeNext_args(object):
    """
    Attributes:
     - sessionId
     - mbData
     - dataLength
    """


    def __init__(self, sessionId=None, mbData=None, dataLength=None,):
        self.sessionId = sessionId
        self.mbData = mbData
        self.dataLength = dataLength

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.mbData = Metadata()
                    self.mbData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.dataLength = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('writeNext_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.mbData is not None:
            oprot.writeFieldBegin('mbData', TType.STRUCT, 2)
            self.mbData.write(oprot)
            oprot.writeFieldEnd()
        if self.dataLength is not None:
            oprot.writeFieldBegin('dataLength', TType.BYTE, 3)
            oprot.writeByte(self.dataLength)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(writeNext_args)
writeNext_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'mbData', [Metadata, None], None, ),  # 2
    (3, TType.BYTE, 'dataLength', None, None, ),  # 3
)


class writeNext_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype184, _size181) = iprot.readListBegin()
                    for _i185 in range(_size181):
                        _elem186 = NodeInfoData()
                        _elem186.read(iprot)
                        self.success.append(_elem186)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('writeNext_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter187 in self.success:
                iter187.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(writeNext_result)
writeNext_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [NodeInfoData, None], False), None, ),  # 0
)


class insertMetadata_args(object):
    """
    Attributes:
     - mbMetadata
     - edgeInfoData
     - metaKeyValueMap
    """


    def __init__(self, mbMetadata=None, edgeInfoData=None, metaKeyValueMap=None,):
        self.mbMetadata = mbMetadata
        self.edgeInfoData = edgeInfoData
        self.metaKeyValueMap = metaKeyValueMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.mbMetadata = Metadata()
                    self.mbMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.edgeInfoData = EdgeInfoData()
                    self.edgeInfoData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.metaKeyValueMap = {}
                    (_ktype189, _vtype190, _size188) = iprot.readMapBegin()
                    for _i192 in range(_size188):
                        _key193 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val194 = []
                        (_etype198, _size195) = iprot.readListBegin()
                        for _i199 in range(_size195):
                            _elem200 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val194.append(_elem200)
                        iprot.readListEnd()
                        self.metaKeyValueMap[_key193] = _val194
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insertMetadata_args')
        if self.mbMetadata is not None:
            oprot.writeFieldBegin('mbMetadata', TType.STRUCT, 1)
            self.mbMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.edgeInfoData is not None:
            oprot.writeFieldBegin('edgeInfoData', TType.STRUCT, 2)
            self.edgeInfoData.write(oprot)
            oprot.writeFieldEnd()
        if self.metaKeyValueMap is not None:
            oprot.writeFieldBegin('metaKeyValueMap', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.metaKeyValueMap))
            for kiter201, viter202 in self.metaKeyValueMap.items():
                oprot.writeString(kiter201.encode('utf-8') if sys.version_info[0] == 2 else kiter201)
                oprot.writeListBegin(TType.STRING, len(viter202))
                for iter203 in viter202:
                    oprot.writeString(iter203.encode('utf-8') if sys.version_info[0] == 2 else iter203)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insertMetadata_args)
insertMetadata_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'mbMetadata', [Metadata, None], None, ),  # 1
    (2, TType.STRUCT, 'edgeInfoData', [EdgeInfoData, None], None, ),  # 2
    (3, TType.MAP, 'metaKeyValueMap', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 3
)


class insertMetadata_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insertMetadata_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insertMetadata_result)
insertMetadata_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class findNext_args(object):
    """
    Attributes:
     - microbatchId
    """


    def __init__(self, microbatchId=None,):
        self.microbatchId = microbatchId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.microbatchId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findNext_args')
        if self.microbatchId is not None:
            oprot.writeFieldBegin('microbatchId', TType.STRING, 1)
            oprot.writeString(self.microbatchId.encode('utf-8') if sys.version_info[0] == 2 else self.microbatchId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findNext_args)
findNext_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'microbatchId', 'UTF8', None, ),  # 1
)


class findNext_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findNext_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findNext_result)
findNext_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class find_args(object):
    """
    Attributes:
     - microbatchId
     - checkNeighbors
     - checkBuddies
     - selfInfo
    """


    def __init__(self, microbatchId=None, checkNeighbors=None, checkBuddies=None, selfInfo=None,):
        self.microbatchId = microbatchId
        self.checkNeighbors = checkNeighbors
        self.checkBuddies = checkBuddies
        self.selfInfo = selfInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.microbatchId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.checkNeighbors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.checkBuddies = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.selfInfo = EdgeInfoData()
                    self.selfInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('find_args')
        if self.microbatchId is not None:
            oprot.writeFieldBegin('microbatchId', TType.I64, 1)
            oprot.writeI64(self.microbatchId)
            oprot.writeFieldEnd()
        if self.checkNeighbors is not None:
            oprot.writeFieldBegin('checkNeighbors', TType.BOOL, 2)
            oprot.writeBool(self.checkNeighbors)
            oprot.writeFieldEnd()
        if self.checkBuddies is not None:
            oprot.writeFieldBegin('checkBuddies', TType.BOOL, 3)
            oprot.writeBool(self.checkBuddies)
            oprot.writeFieldEnd()
        if self.selfInfo is not None:
            oprot.writeFieldBegin('selfInfo', TType.STRUCT, 4)
            self.selfInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(find_args)
find_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'microbatchId', None, None, ),  # 1
    (2, TType.BOOL, 'checkNeighbors', None, None, ),  # 2
    (3, TType.BOOL, 'checkBuddies', None, None, ),  # 3
    (4, TType.STRUCT, 'selfInfo', [EdgeInfoData, None], None, ),  # 4
)


class find_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype207, _size204) = iprot.readListBegin()
                    for _i208 in range(_size204):
                        _elem209 = FindReplica()
                        _elem209.read(iprot)
                        self.success.append(_elem209)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('find_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter210 in self.success:
                iter210.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(find_result)
find_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [FindReplica, None], False), None, ),  # 0
)


class findFast_args(object):
    """
    Attributes:
     - microbatchIdList
     - checkNeighbors
     - checkBuddies
     - selfInfo
    """


    def __init__(self, microbatchIdList=None, checkNeighbors=None, checkBuddies=None, selfInfo=None,):
        self.microbatchIdList = microbatchIdList
        self.checkNeighbors = checkNeighbors
        self.checkBuddies = checkBuddies
        self.selfInfo = selfInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.microbatchIdList = []
                    (_etype214, _size211) = iprot.readListBegin()
                    for _i215 in range(_size211):
                        _elem216 = iprot.readI64()
                        self.microbatchIdList.append(_elem216)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.checkNeighbors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.checkBuddies = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.selfInfo = EdgeInfoData()
                    self.selfInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findFast_args')
        if self.microbatchIdList is not None:
            oprot.writeFieldBegin('microbatchIdList', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.microbatchIdList))
            for iter217 in self.microbatchIdList:
                oprot.writeI64(iter217)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.checkNeighbors is not None:
            oprot.writeFieldBegin('checkNeighbors', TType.BOOL, 2)
            oprot.writeBool(self.checkNeighbors)
            oprot.writeFieldEnd()
        if self.checkBuddies is not None:
            oprot.writeFieldBegin('checkBuddies', TType.BOOL, 3)
            oprot.writeBool(self.checkBuddies)
            oprot.writeFieldEnd()
        if self.selfInfo is not None:
            oprot.writeFieldBegin('selfInfo', TType.STRUCT, 4)
            self.selfInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findFast_args)
findFast_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'microbatchIdList', (TType.I64, None, False), None, ),  # 1
    (2, TType.BOOL, 'checkNeighbors', None, None, ),  # 2
    (3, TType.BOOL, 'checkBuddies', None, None, ),  # 3
    (4, TType.STRUCT, 'selfInfo', [EdgeInfoData, None], None, ),  # 4
)


class findFast_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype219, _vtype220, _size218) = iprot.readMapBegin()
                    for _i222 in range(_size218):
                        _key223 = iprot.readI64()
                        _val224 = []
                        (_etype228, _size225) = iprot.readListBegin()
                        for _i229 in range(_size225):
                            _elem230 = FindReplica()
                            _elem230.read(iprot)
                            _val224.append(_elem230)
                        iprot.readListEnd()
                        self.success[_key223] = _val224
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findFast_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.LIST, len(self.success))
            for kiter231, viter232 in self.success.items():
                oprot.writeI64(kiter231)
                oprot.writeListBegin(TType.STRUCT, len(viter232))
                for iter233 in viter232:
                    iter233.write(oprot)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findFast_result)
findFast_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.LIST, (TType.STRUCT, [FindReplica, None], False), False), None, ),  # 0
)


class read_args(object):
    """
    Attributes:
     - microbatchId
     - fetchMetadata
     - compFormat
     - uncompSize
    """


    def __init__(self, microbatchId=None, fetchMetadata=None, compFormat=None, uncompSize=None,):
        self.microbatchId = microbatchId
        self.fetchMetadata = fetchMetadata
        self.compFormat = compFormat
        self.uncompSize = uncompSize

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.microbatchId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.fetchMetadata = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.compFormat = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.uncompSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_args')
        if self.microbatchId is not None:
            oprot.writeFieldBegin('microbatchId', TType.I64, 1)
            oprot.writeI64(self.microbatchId)
            oprot.writeFieldEnd()
        if self.fetchMetadata is not None:
            oprot.writeFieldBegin('fetchMetadata', TType.BOOL, 2)
            oprot.writeBool(self.fetchMetadata)
            oprot.writeFieldEnd()
        if self.compFormat is not None:
            oprot.writeFieldBegin('compFormat', TType.STRING, 3)
            oprot.writeString(self.compFormat.encode('utf-8') if sys.version_info[0] == 2 else self.compFormat)
            oprot.writeFieldEnd()
        if self.uncompSize is not None:
            oprot.writeFieldBegin('uncompSize', TType.I64, 4)
            oprot.writeI64(self.uncompSize)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_args)
read_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'microbatchId', None, None, ),  # 1
    (2, TType.BOOL, 'fetchMetadata', None, None, ),  # 2
    (3, TType.STRING, 'compFormat', 'UTF8', None, ),  # 3
    (4, TType.I64, 'uncompSize', None, None, ),  # 4
)


class read_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ReadReplica()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_result)
read_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ReadReplica, None], None, ),  # 0
)


class findUsingQuery_args(object):
    """
    Attributes:
     - metadataKey
     - metadataValue
     - checkNeighbors
     - checkBuddies
    """


    def __init__(self, metadataKey=None, metadataValue=None, checkNeighbors=None, checkBuddies=None,):
        self.metadataKey = metadataKey
        self.metadataValue = metadataValue
        self.checkNeighbors = checkNeighbors
        self.checkBuddies = checkBuddies

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.metadataKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.metadataValue = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.checkNeighbors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.checkBuddies = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findUsingQuery_args')
        if self.metadataKey is not None:
            oprot.writeFieldBegin('metadataKey', TType.STRING, 1)
            oprot.writeString(self.metadataKey.encode('utf-8') if sys.version_info[0] == 2 else self.metadataKey)
            oprot.writeFieldEnd()
        if self.metadataValue is not None:
            oprot.writeFieldBegin('metadataValue', TType.STRING, 2)
            oprot.writeString(self.metadataValue.encode('utf-8') if sys.version_info[0] == 2 else self.metadataValue)
            oprot.writeFieldEnd()
        if self.checkNeighbors is not None:
            oprot.writeFieldBegin('checkNeighbors', TType.BOOL, 3)
            oprot.writeBool(self.checkNeighbors)
            oprot.writeFieldEnd()
        if self.checkBuddies is not None:
            oprot.writeFieldBegin('checkBuddies', TType.BOOL, 4)
            oprot.writeBool(self.checkBuddies)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findUsingQuery_args)
findUsingQuery_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'metadataKey', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'metadataValue', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'checkNeighbors', None, None, ),  # 3
    (4, TType.BOOL, 'checkBuddies', None, None, ),  # 4
)


class findUsingQuery_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = QueryReplica()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findUsingQuery_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findUsingQuery_result)
findUsingQuery_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [QueryReplica, None], None, ),  # 0
)


class getMeta_args(object):
    """
    Attributes:
     - microbatchId
     - checkNeighbors
     - checkBuddies
    """


    def __init__(self, microbatchId=None, checkNeighbors=None, checkBuddies=None,):
        self.microbatchId = microbatchId
        self.checkNeighbors = checkNeighbors
        self.checkBuddies = checkBuddies

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.microbatchId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.checkNeighbors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.checkBuddies = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMeta_args')
        if self.microbatchId is not None:
            oprot.writeFieldBegin('microbatchId', TType.I64, 1)
            oprot.writeI64(self.microbatchId)
            oprot.writeFieldEnd()
        if self.checkNeighbors is not None:
            oprot.writeFieldBegin('checkNeighbors', TType.BOOL, 2)
            oprot.writeBool(self.checkNeighbors)
            oprot.writeFieldEnd()
        if self.checkBuddies is not None:
            oprot.writeFieldBegin('checkBuddies', TType.BOOL, 3)
            oprot.writeBool(self.checkBuddies)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMeta_args)
getMeta_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'microbatchId', None, None, ),  # 1
    (2, TType.BOOL, 'checkNeighbors', None, None, ),  # 2
    (3, TType.BOOL, 'checkBuddies', None, None, ),  # 3
)


class getMeta_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ReadReplica()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMeta_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMeta_result)
getMeta_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ReadReplica, None], None, ),  # 0
)


class serializeState_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('serializeState_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(serializeState_args)
serializeState_args.thrift_spec = (
)


class serializeState_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('serializeState_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(serializeState_result)
serializeState_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class updateStreamMetadata_args(object):
    """
    Attributes:
     - metadata
    """


    def __init__(self, metadata=None,):
        self.metadata = metadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.metadata = StreamMetadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateStreamMetadata_args')
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 1)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateStreamMetadata_args)
updateStreamMetadata_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'metadata', [StreamMetadata, None], None, ),  # 1
)


class updateStreamMetadata_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StreamMetadataUpdateResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateStreamMetadata_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateStreamMetadata_result)
updateStreamMetadata_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [StreamMetadataUpdateResponse, None], None, ),  # 0
)


class open_args(object):
    """
    Attributes:
     - streamId
     - clientId
     - expectedLease
     - setLease
    """


    def __init__(self, streamId=None, clientId=None, expectedLease=None, setLease=None,):
        self.streamId = streamId
        self.clientId = clientId
        self.expectedLease = expectedLease
        self.setLease = setLease

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.streamId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.expectedLease = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.setLease = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_args')
        if self.streamId is not None:
            oprot.writeFieldBegin('streamId', TType.STRING, 1)
            oprot.writeString(self.streamId.encode('utf-8') if sys.version_info[0] == 2 else self.streamId)
            oprot.writeFieldEnd()
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 2)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        if self.expectedLease is not None:
            oprot.writeFieldBegin('expectedLease', TType.I32, 3)
            oprot.writeI32(self.expectedLease)
            oprot.writeFieldEnd()
        if self.setLease is not None:
            oprot.writeFieldBegin('setLease', TType.BOOL, 4)
            oprot.writeBool(self.setLease)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_args)
open_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'streamId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'clientId', 'UTF8', None, ),  # 2
    (3, TType.I32, 'expectedLease', None, None, ),  # 3
    (4, TType.BOOL, 'setLease', None, None, ),  # 4
)


class open_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = OpenStreamResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('open_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(open_result)
open_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [OpenStreamResponse, None], None, ),  # 0
)


class putNext_args(object):
    """
    Attributes:
     - mbMetadata
     - data
     - preference
     - metaKeyValueMap
    """


    def __init__(self, mbMetadata=None, data=None, preference=None, metaKeyValueMap=None,):
        self.mbMetadata = mbMetadata
        self.data = data
        self.preference = preference
        self.metaKeyValueMap = metaKeyValueMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.mbMetadata = Metadata()
                    self.mbMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.preference = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.metaKeyValueMap = {}
                    (_ktype235, _vtype236, _size234) = iprot.readMapBegin()
                    for _i238 in range(_size234):
                        _key239 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val240 = []
                        (_etype244, _size241) = iprot.readListBegin()
                        for _i245 in range(_size241):
                            _elem246 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val240.append(_elem246)
                        iprot.readListEnd()
                        self.metaKeyValueMap[_key239] = _val240
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('putNext_args')
        if self.mbMetadata is not None:
            oprot.writeFieldBegin('mbMetadata', TType.STRUCT, 1)
            self.mbMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 2)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.preference is not None:
            oprot.writeFieldBegin('preference', TType.I32, 3)
            oprot.writeI32(self.preference)
            oprot.writeFieldEnd()
        if self.metaKeyValueMap is not None:
            oprot.writeFieldBegin('metaKeyValueMap', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.metaKeyValueMap))
            for kiter247, viter248 in self.metaKeyValueMap.items():
                oprot.writeString(kiter247.encode('utf-8') if sys.version_info[0] == 2 else kiter247)
                oprot.writeListBegin(TType.STRING, len(viter248))
                for iter249 in viter248:
                    oprot.writeString(iter249.encode('utf-8') if sys.version_info[0] == 2 else iter249)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(putNext_args)
putNext_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'mbMetadata', [Metadata, None], None, ),  # 1
    (2, TType.STRING, 'data', 'BINARY', None, ),  # 2
    (3, TType.I32, 'preference', None, None, ),  # 3
    (4, TType.MAP, 'metaKeyValueMap', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
)


class putNext_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WriteResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('putNext_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(putNext_result)
putNext_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [WriteResponse, None], None, ),  # 0
)


class incrementBlockCount_args(object):
    """
    Attributes:
     - mbMetadata
     - setLease
    """


    def __init__(self, mbMetadata=None, setLease=None,):
        self.mbMetadata = mbMetadata
        self.setLease = setLease

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.mbMetadata = Metadata()
                    self.mbMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.setLease = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('incrementBlockCount_args')
        if self.mbMetadata is not None:
            oprot.writeFieldBegin('mbMetadata', TType.STRUCT, 1)
            self.mbMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.setLease is not None:
            oprot.writeFieldBegin('setLease', TType.BOOL, 2)
            oprot.writeBool(self.setLease)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(incrementBlockCount_args)
incrementBlockCount_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'mbMetadata', [Metadata, None], None, ),  # 1
    (2, TType.BOOL, 'setLease', None, None, ),  # 2
)


class incrementBlockCount_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = BlockMetadataUpdateResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('incrementBlockCount_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(incrementBlockCount_result)
incrementBlockCount_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [BlockMetadataUpdateResponse, None], None, ),  # 0
)


class renewLease_args(object):
    """
    Attributes:
     - streamId
     - clientId
     - sessionSecret
     - expectedLease
     - setLease
    """


    def __init__(self, streamId=None, clientId=None, sessionSecret=None, expectedLease=None, setLease=None,):
        self.streamId = streamId
        self.clientId = clientId
        self.sessionSecret = sessionSecret
        self.expectedLease = expectedLease
        self.setLease = setLease

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.streamId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.sessionSecret = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.expectedLease = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.setLease = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('renewLease_args')
        if self.streamId is not None:
            oprot.writeFieldBegin('streamId', TType.STRING, 1)
            oprot.writeString(self.streamId.encode('utf-8') if sys.version_info[0] == 2 else self.streamId)
            oprot.writeFieldEnd()
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 2)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        if self.sessionSecret is not None:
            oprot.writeFieldBegin('sessionSecret', TType.STRING, 3)
            oprot.writeString(self.sessionSecret.encode('utf-8') if sys.version_info[0] == 2 else self.sessionSecret)
            oprot.writeFieldEnd()
        if self.expectedLease is not None:
            oprot.writeFieldBegin('expectedLease', TType.I32, 4)
            oprot.writeI32(self.expectedLease)
            oprot.writeFieldEnd()
        if self.setLease is not None:
            oprot.writeFieldBegin('setLease', TType.BOOL, 5)
            oprot.writeBool(self.setLease)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(renewLease_args)
renewLease_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'streamId', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'clientId', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'sessionSecret', 'UTF8', None, ),  # 3
    (4, TType.I32, 'expectedLease', None, None, ),  # 4
    (5, TType.BOOL, 'setLease', None, None, ),  # 5
)


class renewLease_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StreamLeaseRenewalResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('renewLease_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(renewLease_result)
renewLease_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [StreamLeaseRenewalResponse, None], None, ),  # 0
)


class getLargestBlockId_args(object):
    """
    Attributes:
     - streamId
    """


    def __init__(self, streamId=None,):
        self.streamId = streamId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.streamId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLargestBlockId_args')
        if self.streamId is not None:
            oprot.writeFieldBegin('streamId', TType.STRING, 1)
            oprot.writeString(self.streamId.encode('utf-8') if sys.version_info[0] == 2 else self.streamId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLargestBlockId_args)
getLargestBlockId_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'streamId', 'UTF8', None, ),  # 1
)


class getLargestBlockId_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getLargestBlockId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getLargestBlockId_result)
getLargestBlockId_result.thrift_spec = (
    (0, TType.I64, 'success', None, None, ),  # 0
)


class findStream_args(object):
    """
    Attributes:
     - squery
    """


    def __init__(self, squery=None,):
        self.squery = squery

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.squery = SQueryRequest()
                    self.squery.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findStream_args')
        if self.squery is not None:
            oprot.writeFieldBegin('squery', TType.STRUCT, 1)
            self.squery.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findStream_args)
findStream_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'squery', [SQueryRequest, None], None, ),  # 1
)


class findStream_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = SQueryResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findStream_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findStream_result)
findStream_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [SQueryResponse, None], None, ),  # 0
)


class updateBlock_args(object):
    """
    Attributes:
     - mbId
     - mbMetadata
     - mbData
    """


    def __init__(self, mbId=None, mbMetadata=None, mbData=None,):
        self.mbId = mbId
        self.mbMetadata = mbMetadata
        self.mbData = mbData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mbId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.mbMetadata = Metadata()
                    self.mbMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.mbData = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateBlock_args')
        if self.mbId is not None:
            oprot.writeFieldBegin('mbId', TType.I64, 1)
            oprot.writeI64(self.mbId)
            oprot.writeFieldEnd()
        if self.mbMetadata is not None:
            oprot.writeFieldBegin('mbMetadata', TType.STRUCT, 2)
            self.mbMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.mbData is not None:
            oprot.writeFieldBegin('mbData', TType.STRING, 3)
            oprot.writeBinary(self.mbData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateBlock_args)
updateBlock_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mbId', None, None, ),  # 1
    (2, TType.STRUCT, 'mbMetadata', [Metadata, None], None, ),  # 2
    (3, TType.STRING, 'mbData', 'BINARY', None, ),  # 3
)


class updateBlock_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WriteResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('updateBlock_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(updateBlock_result)
updateBlock_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [WriteResponse, None], None, ),  # 0
)


class listLocalPartitionMbId_args(object):
    """
    Attributes:
     - flag
    """


    def __init__(self, flag=None,):
        self.flag = flag

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.flag = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listLocalPartitionMbId_args')
        if self.flag is not None:
            oprot.writeFieldBegin('flag', TType.BOOL, 1)
            oprot.writeBool(self.flag)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listLocalPartitionMbId_args)
listLocalPartitionMbId_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'flag', None, None, ),  # 1
)


class listLocalPartitionMbId_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_etype253, _size250) = iprot.readSetBegin()
                    for _i254 in range(_size250):
                        _elem255 = iprot.readI64()
                        self.success.add(_elem255)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('listLocalPartitionMbId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.I64, len(self.success))
            for iter256 in self.success:
                oprot.writeI64(iter256)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(listLocalPartitionMbId_result)
listLocalPartitionMbId_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.I64, None, False), None, ),  # 0
)


class requestAllNeighbors_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestAllNeighbors_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestAllNeighbors_args)
requestAllNeighbors_args.thrift_spec = (
)


class requestAllNeighbors_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype260, _size257) = iprot.readListBegin()
                    for _i261 in range(_size257):
                        _elem262 = NeighborInfoData()
                        _elem262.read(iprot)
                        self.success.append(_elem262)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestAllNeighbors_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter263 in self.success:
                iter263.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestAllNeighbors_result)
requestAllNeighbors_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [NeighborInfoData, None], False), None, ),  # 0
)


class requestEdgeMicrobatchMap_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestEdgeMicrobatchMap_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestEdgeMicrobatchMap_args)
requestEdgeMicrobatchMap_args.thrift_spec = (
)


class requestEdgeMicrobatchMap_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype265, _vtype266, _size264) = iprot.readMapBegin()
                    for _i268 in range(_size264):
                        _key269 = iprot.readI16()
                        _val270 = set()
                        (_etype274, _size271) = iprot.readSetBegin()
                        for _i275 in range(_size271):
                            _elem276 = iprot.readI64()
                            _val270.add(_elem276)
                        iprot.readSetEnd()
                        self.success[_key269] = _val270
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestEdgeMicrobatchMap_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I16, TType.SET, len(self.success))
            for kiter277, viter278 in self.success.items():
                oprot.writeI16(kiter277)
                oprot.writeSetBegin(TType.I64, len(viter278))
                for iter279 in viter278:
                    oprot.writeI64(iter279)
                oprot.writeSetEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestEdgeMicrobatchMap_result)
requestEdgeMicrobatchMap_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I16, None, TType.SET, (TType.I64, None, False), False), None, ),  # 0
)


class requestCompFormatSize_args(object):
    """
    Attributes:
     - mbId
    """


    def __init__(self, mbId=None,):
        self.mbId = mbId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mbId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestCompFormatSize_args')
        if self.mbId is not None:
            oprot.writeFieldBegin('mbId', TType.I64, 1)
            oprot.writeI64(self.mbId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestCompFormatSize_args)
requestCompFormatSize_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mbId', None, None, ),  # 1
)


class requestCompFormatSize_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype281, _vtype282, _size280) = iprot.readMapBegin()
                    for _i284 in range(_size280):
                        _key285 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val286 = iprot.readI64()
                        self.success[_key285] = _val286
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestCompFormatSize_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.I64, len(self.success))
            for kiter287, viter288 in self.success.items():
                oprot.writeString(kiter287.encode('utf-8') if sys.version_info[0] == 2 else kiter287)
                oprot.writeI64(viter288)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestCompFormatSize_result)
requestCompFormatSize_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.I64, None, False), None, ),  # 0
)


class findStreamUsingQuery_args(object):
    """
    Attributes:
     - metaKeyValueMap
     - checkNeighbors
     - checkBuddies
    """


    def __init__(self, metaKeyValueMap=None, checkNeighbors=None, checkBuddies=None,):
        self.metaKeyValueMap = metaKeyValueMap
        self.checkNeighbors = checkNeighbors
        self.checkBuddies = checkBuddies

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.metaKeyValueMap = {}
                    (_ktype290, _vtype291, _size289) = iprot.readMapBegin()
                    for _i293 in range(_size289):
                        _key294 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val295 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.metaKeyValueMap[_key294] = _val295
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.checkNeighbors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.checkBuddies = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findStreamUsingQuery_args')
        if self.metaKeyValueMap is not None:
            oprot.writeFieldBegin('metaKeyValueMap', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metaKeyValueMap))
            for kiter296, viter297 in self.metaKeyValueMap.items():
                oprot.writeString(kiter296.encode('utf-8') if sys.version_info[0] == 2 else kiter296)
                oprot.writeString(viter297.encode('utf-8') if sys.version_info[0] == 2 else viter297)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.checkNeighbors is not None:
            oprot.writeFieldBegin('checkNeighbors', TType.BOOL, 2)
            oprot.writeBool(self.checkNeighbors)
            oprot.writeFieldEnd()
        if self.checkBuddies is not None:
            oprot.writeFieldBegin('checkBuddies', TType.BOOL, 3)
            oprot.writeBool(self.checkBuddies)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findStreamUsingQuery_args)
findStreamUsingQuery_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'metaKeyValueMap', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.BOOL, 'checkNeighbors', None, None, ),  # 2
    (3, TType.BOOL, 'checkBuddies', None, None, ),  # 3
)


class findStreamUsingQuery_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.SET:
                    self.success = set()
                    (_etype301, _size298) = iprot.readSetBegin()
                    for _i302 in range(_size298):
                        _elem303 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.add(_elem303)
                    iprot.readSetEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findStreamUsingQuery_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.SET, 0)
            oprot.writeSetBegin(TType.STRING, len(self.success))
            for iter304 in self.success:
                oprot.writeString(iter304.encode('utf-8') if sys.version_info[0] == 2 else iter304)
            oprot.writeSetEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findStreamUsingQuery_result)
findStreamUsingQuery_result.thrift_spec = (
    (0, TType.SET, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
)


class findBlockUsingQuery_args(object):
    """
    Attributes:
     - metaKeyValueMap
     - checkNeighbors
     - checkBuddies
     - matchpreference
    """


    def __init__(self, metaKeyValueMap=None, checkNeighbors=None, checkBuddies=None, matchpreference=None,):
        self.metaKeyValueMap = metaKeyValueMap
        self.checkNeighbors = checkNeighbors
        self.checkBuddies = checkBuddies
        self.matchpreference = matchpreference

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.metaKeyValueMap = {}
                    (_ktype306, _vtype307, _size305) = iprot.readMapBegin()
                    for _i309 in range(_size305):
                        _key310 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val311 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.metaKeyValueMap[_key310] = _val311
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.checkNeighbors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.checkBuddies = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.matchpreference = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findBlockUsingQuery_args')
        if self.metaKeyValueMap is not None:
            oprot.writeFieldBegin('metaKeyValueMap', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.metaKeyValueMap))
            for kiter312, viter313 in self.metaKeyValueMap.items():
                oprot.writeString(kiter312.encode('utf-8') if sys.version_info[0] == 2 else kiter312)
                oprot.writeString(viter313.encode('utf-8') if sys.version_info[0] == 2 else viter313)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.checkNeighbors is not None:
            oprot.writeFieldBegin('checkNeighbors', TType.BOOL, 2)
            oprot.writeBool(self.checkNeighbors)
            oprot.writeFieldEnd()
        if self.checkBuddies is not None:
            oprot.writeFieldBegin('checkBuddies', TType.BOOL, 3)
            oprot.writeBool(self.checkBuddies)
            oprot.writeFieldEnd()
        if self.matchpreference is not None:
            oprot.writeFieldBegin('matchpreference', TType.I32, 4)
            oprot.writeI32(self.matchpreference)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findBlockUsingQuery_args)
findBlockUsingQuery_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'metaKeyValueMap', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.BOOL, 'checkNeighbors', None, None, ),  # 2
    (3, TType.BOOL, 'checkBuddies', None, None, ),  # 3
    (4, TType.I32, 'matchpreference', None, None, ),  # 4
)


class findBlockUsingQuery_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype315, _vtype316, _size314) = iprot.readMapBegin()
                    for _i318 in range(_size314):
                        _key319 = iprot.readI64()
                        _val320 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key319] = _val320
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findBlockUsingQuery_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.I64, TType.STRING, len(self.success))
            for kiter321, viter322 in self.success.items():
                oprot.writeI64(kiter321)
                oprot.writeString(viter322.encode('utf-8') if sys.version_info[0] == 2 else viter322)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findBlockUsingQuery_result)
findBlockUsingQuery_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.I64, None, TType.STRING, 'UTF8', False), None, ),  # 0
)


class findBlocksAndLocationsWithQuery_args(object):
    """
    Attributes:
     - checkNeighbors
     - checkBuddies
     - queryCondition
     - replicacount
     - edgeInfo
    """


    def __init__(self, checkNeighbors=None, checkBuddies=None, queryCondition=None, replicacount=None, edgeInfo=None,):
        self.checkNeighbors = checkNeighbors
        self.checkBuddies = checkBuddies
        self.queryCondition = queryCondition
        self.replicacount = replicacount
        self.edgeInfo = edgeInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.checkNeighbors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.checkBuddies = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.queryCondition = []
                    (_etype326, _size323) = iprot.readListBegin()
                    for _i327 in range(_size323):
                        _elem328 = []
                        (_etype332, _size329) = iprot.readListBegin()
                        for _i333 in range(_size329):
                            _elem334 = FindQueryCondition()
                            _elem334.read(iprot)
                            _elem328.append(_elem334)
                        iprot.readListEnd()
                        self.queryCondition.append(_elem328)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.replicacount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.edgeInfo = EdgeInfoData()
                    self.edgeInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findBlocksAndLocationsWithQuery_args')
        if self.checkNeighbors is not None:
            oprot.writeFieldBegin('checkNeighbors', TType.BOOL, 1)
            oprot.writeBool(self.checkNeighbors)
            oprot.writeFieldEnd()
        if self.checkBuddies is not None:
            oprot.writeFieldBegin('checkBuddies', TType.BOOL, 2)
            oprot.writeBool(self.checkBuddies)
            oprot.writeFieldEnd()
        if self.queryCondition is not None:
            oprot.writeFieldBegin('queryCondition', TType.LIST, 3)
            oprot.writeListBegin(TType.LIST, len(self.queryCondition))
            for iter335 in self.queryCondition:
                oprot.writeListBegin(TType.STRUCT, len(iter335))
                for iter336 in iter335:
                    iter336.write(oprot)
                oprot.writeListEnd()
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.replicacount is not None:
            oprot.writeFieldBegin('replicacount', TType.I32, 4)
            oprot.writeI32(self.replicacount)
            oprot.writeFieldEnd()
        if self.edgeInfo is not None:
            oprot.writeFieldBegin('edgeInfo', TType.STRUCT, 5)
            self.edgeInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findBlocksAndLocationsWithQuery_args)
findBlocksAndLocationsWithQuery_args.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'checkNeighbors', None, None, ),  # 1
    (2, TType.BOOL, 'checkBuddies', None, None, ),  # 2
    (3, TType.LIST, 'queryCondition', (TType.LIST, (TType.STRUCT, [FindQueryCondition, None], False), False), None, ),  # 3
    (4, TType.I32, 'replicacount', None, None, ),  # 4
    (5, TType.STRUCT, 'edgeInfo', [EdgeInfoData, None], None, ),  # 5
)


class findBlocksAndLocationsWithQuery_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FindBlockQueryResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findBlocksAndLocationsWithQuery_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findBlocksAndLocationsWithQuery_result)
findBlocksAndLocationsWithQuery_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [FindBlockQueryResponse, None], None, ),  # 0
)


class getMetadataByBlockid_args(object):
    """
    Attributes:
     - mbid
     - fogip
     - fogport
     - edgeInfoData
     - keys
    """


    def __init__(self, mbid=None, fogip=None, fogport=None, edgeInfoData=None, keys=None,):
        self.mbid = mbid
        self.fogip = fogip
        self.fogport = fogport
        self.edgeInfoData = edgeInfoData
        self.keys = keys

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.mbid = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.fogip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fogport = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.edgeInfoData = EdgeInfoData()
                    self.edgeInfoData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype340, _size337) = iprot.readListBegin()
                    for _i341 in range(_size337):
                        _elem342 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem342)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMetadataByBlockid_args')
        if self.mbid is not None:
            oprot.writeFieldBegin('mbid', TType.I64, 1)
            oprot.writeI64(self.mbid)
            oprot.writeFieldEnd()
        if self.fogip is not None:
            oprot.writeFieldBegin('fogip', TType.STRING, 2)
            oprot.writeString(self.fogip.encode('utf-8') if sys.version_info[0] == 2 else self.fogip)
            oprot.writeFieldEnd()
        if self.fogport is not None:
            oprot.writeFieldBegin('fogport', TType.I32, 3)
            oprot.writeI32(self.fogport)
            oprot.writeFieldEnd()
        if self.edgeInfoData is not None:
            oprot.writeFieldBegin('edgeInfoData', TType.STRUCT, 4)
            self.edgeInfoData.write(oprot)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter343 in self.keys:
                oprot.writeString(iter343.encode('utf-8') if sys.version_info[0] == 2 else iter343)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMetadataByBlockid_args)
getMetadataByBlockid_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'mbid', None, None, ),  # 1
    (2, TType.STRING, 'fogip', 'UTF8', None, ),  # 2
    (3, TType.I32, 'fogport', None, None, ),  # 3
    (4, TType.STRUCT, 'edgeInfoData', [EdgeInfoData, None], None, ),  # 4
    (5, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 5
)


class getMetadataByBlockid_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = MetadataResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getMetadataByBlockid_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getMetadataByBlockid_result)
getMetadataByBlockid_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [MetadataResponse, None], None, ),  # 0
)


class getManyMetadataByBlockidList_args(object):
    """
    Attributes:
     - mbidList
     - fogip
     - fogport
     - edgeInfoData
     - keys
    """


    def __init__(self, mbidList=None, fogip=None, fogport=None, edgeInfoData=None, keys=None,):
        self.mbidList = mbidList
        self.fogip = fogip
        self.fogport = fogport
        self.edgeInfoData = edgeInfoData
        self.keys = keys

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.mbidList = []
                    (_etype347, _size344) = iprot.readListBegin()
                    for _i348 in range(_size344):
                        _elem349 = iprot.readI64()
                        self.mbidList.append(_elem349)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.fogip = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.fogport = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.edgeInfoData = EdgeInfoData()
                    self.edgeInfoData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype353, _size350) = iprot.readListBegin()
                    for _i354 in range(_size350):
                        _elem355 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.keys.append(_elem355)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getManyMetadataByBlockidList_args')
        if self.mbidList is not None:
            oprot.writeFieldBegin('mbidList', TType.LIST, 1)
            oprot.writeListBegin(TType.I64, len(self.mbidList))
            for iter356 in self.mbidList:
                oprot.writeI64(iter356)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fogip is not None:
            oprot.writeFieldBegin('fogip', TType.STRING, 2)
            oprot.writeString(self.fogip.encode('utf-8') if sys.version_info[0] == 2 else self.fogip)
            oprot.writeFieldEnd()
        if self.fogport is not None:
            oprot.writeFieldBegin('fogport', TType.I32, 3)
            oprot.writeI32(self.fogport)
            oprot.writeFieldEnd()
        if self.edgeInfoData is not None:
            oprot.writeFieldBegin('edgeInfoData', TType.STRUCT, 4)
            self.edgeInfoData.write(oprot)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.keys))
            for iter357 in self.keys:
                oprot.writeString(iter357.encode('utf-8') if sys.version_info[0] == 2 else iter357)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getManyMetadataByBlockidList_args)
getManyMetadataByBlockidList_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'mbidList', (TType.I64, None, False), None, ),  # 1
    (2, TType.STRING, 'fogip', 'UTF8', None, ),  # 2
    (3, TType.I32, 'fogport', None, None, ),  # 3
    (4, TType.STRUCT, 'edgeInfoData', [EdgeInfoData, None], None, ),  # 4
    (5, TType.LIST, 'keys', (TType.STRING, 'UTF8', False), None, ),  # 5
)


class getManyMetadataByBlockidList_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype361, _size358) = iprot.readListBegin()
                    for _i362 in range(_size358):
                        _elem363 = MetadataResponse()
                        _elem363.read(iprot)
                        self.success.append(_elem363)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getManyMetadataByBlockidList_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter364 in self.success:
                iter364.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getManyMetadataByBlockidList_result)
getManyMetadataByBlockidList_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [MetadataResponse, None], False), None, ),  # 0
)


class putData_args(object):
    """
    Attributes:
     - mbMetadata
     - version
     - data
     - preference
     - metaKeyValueMap
     - clientId
    """


    def __init__(self, mbMetadata=None, version=None, data=None, preference=None, metaKeyValueMap=None, clientId=None,):
        self.mbMetadata = mbMetadata
        self.version = version
        self.data = data
        self.preference = preference
        self.metaKeyValueMap = metaKeyValueMap
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.mbMetadata = Metadata()
                    self.mbMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.version = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.preference = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.metaKeyValueMap = {}
                    (_ktype366, _vtype367, _size365) = iprot.readMapBegin()
                    for _i369 in range(_size365):
                        _key370 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val371 = []
                        (_etype375, _size372) = iprot.readListBegin()
                        for _i376 in range(_size372):
                            _elem377 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val371.append(_elem377)
                        iprot.readListEnd()
                        self.metaKeyValueMap[_key370] = _val371
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('putData_args')
        if self.mbMetadata is not None:
            oprot.writeFieldBegin('mbMetadata', TType.STRUCT, 1)
            self.mbMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I16, 2)
            oprot.writeI16(self.version)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 3)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.preference is not None:
            oprot.writeFieldBegin('preference', TType.I32, 4)
            oprot.writeI32(self.preference)
            oprot.writeFieldEnd()
        if self.metaKeyValueMap is not None:
            oprot.writeFieldBegin('metaKeyValueMap', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.metaKeyValueMap))
            for kiter378, viter379 in self.metaKeyValueMap.items():
                oprot.writeString(kiter378.encode('utf-8') if sys.version_info[0] == 2 else kiter378)
                oprot.writeListBegin(TType.STRING, len(viter379))
                for iter380 in viter379:
                    oprot.writeString(iter380.encode('utf-8') if sys.version_info[0] == 2 else iter380)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 6)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(putData_args)
putData_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'mbMetadata', [Metadata, None], None, ),  # 1
    (2, TType.I16, 'version', None, None, ),  # 2
    (3, TType.STRING, 'data', 'BINARY', None, ),  # 3
    (4, TType.I32, 'preference', None, None, ),  # 4
    (5, TType.MAP, 'metaKeyValueMap', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 5
    (6, TType.STRING, 'clientId', 'UTF8', None, ),  # 6
)


class putData_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WriteResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('putData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(putData_result)
putData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [WriteResponse, None], None, ),  # 0
)


class putDataQuorum_args(object):
    """
    Attributes:
     - mbMetadata
     - version
     - data
     - metaKeyValueMap
     - clientid
    """


    def __init__(self, mbMetadata=None, version=None, data=None, metaKeyValueMap=None, clientid=None,):
        self.mbMetadata = mbMetadata
        self.version = version
        self.data = data
        self.metaKeyValueMap = metaKeyValueMap
        self.clientid = clientid

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.mbMetadata = Metadata()
                    self.mbMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.version = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.metaKeyValueMap = {}
                    (_ktype382, _vtype383, _size381) = iprot.readMapBegin()
                    for _i385 in range(_size381):
                        _key386 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val387 = []
                        (_etype391, _size388) = iprot.readListBegin()
                        for _i392 in range(_size388):
                            _elem393 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                            _val387.append(_elem393)
                        iprot.readListEnd()
                        self.metaKeyValueMap[_key386] = _val387
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.clientid = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('putDataQuorum_args')
        if self.mbMetadata is not None:
            oprot.writeFieldBegin('mbMetadata', TType.STRUCT, 1)
            self.mbMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.I16, 2)
            oprot.writeI16(self.version)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 3)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.metaKeyValueMap is not None:
            oprot.writeFieldBegin('metaKeyValueMap', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.LIST, len(self.metaKeyValueMap))
            for kiter394, viter395 in self.metaKeyValueMap.items():
                oprot.writeString(kiter394.encode('utf-8') if sys.version_info[0] == 2 else kiter394)
                oprot.writeListBegin(TType.STRING, len(viter395))
                for iter396 in viter395:
                    oprot.writeString(iter396.encode('utf-8') if sys.version_info[0] == 2 else iter396)
                oprot.writeListEnd()
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.clientid is not None:
            oprot.writeFieldBegin('clientid', TType.STRING, 5)
            oprot.writeString(self.clientid.encode('utf-8') if sys.version_info[0] == 2 else self.clientid)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(putDataQuorum_args)
putDataQuorum_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'mbMetadata', [Metadata, None], None, ),  # 1
    (2, TType.I16, 'version', None, None, ),  # 2
    (3, TType.STRING, 'data', 'BINARY', None, ),  # 3
    (4, TType.MAP, 'metaKeyValueMap', (TType.STRING, 'UTF8', TType.LIST, (TType.STRING, 'UTF8', False), False), None, ),  # 4
    (5, TType.STRING, 'clientid', 'UTF8', None, ),  # 5
)


class putDataQuorum_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = WriteResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('putDataQuorum_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(putDataQuorum_result)
putDataQuorum_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [WriteResponse, None], None, ),  # 0
)


class get_args(object):
    """
    Attributes:
     - microbatchId
     - fetchMetadata
     - compFormat
     - uncompSize
     - clientId
    """


    def __init__(self, microbatchId=None, fetchMetadata=None, compFormat=None, uncompSize=None, clientId=None,):
        self.microbatchId = microbatchId
        self.fetchMetadata = fetchMetadata
        self.compFormat = compFormat
        self.uncompSize = uncompSize
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.microbatchId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.fetchMetadata = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.compFormat = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.uncompSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.clientId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_args')
        if self.microbatchId is not None:
            oprot.writeFieldBegin('microbatchId', TType.I64, 1)
            oprot.writeI64(self.microbatchId)
            oprot.writeFieldEnd()
        if self.fetchMetadata is not None:
            oprot.writeFieldBegin('fetchMetadata', TType.BOOL, 2)
            oprot.writeBool(self.fetchMetadata)
            oprot.writeFieldEnd()
        if self.compFormat is not None:
            oprot.writeFieldBegin('compFormat', TType.STRING, 3)
            oprot.writeString(self.compFormat.encode('utf-8') if sys.version_info[0] == 2 else self.compFormat)
            oprot.writeFieldEnd()
        if self.uncompSize is not None:
            oprot.writeFieldBegin('uncompSize', TType.I64, 4)
            oprot.writeI64(self.uncompSize)
            oprot.writeFieldEnd()
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.STRING, 5)
            oprot.writeString(self.clientId.encode('utf-8') if sys.version_info[0] == 2 else self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_args)
get_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'microbatchId', None, None, ),  # 1
    (2, TType.BOOL, 'fetchMetadata', None, None, ),  # 2
    (3, TType.STRING, 'compFormat', 'UTF8', None, ),  # 3
    (4, TType.I64, 'uncompSize', None, None, ),  # 4
    (5, TType.STRING, 'clientId', 'UTF8', None, ),  # 5
)


class get_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ReadReplica()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_result)
get_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ReadReplica, None], None, ),  # 0
)


class getData_args(object):
    """
    Attributes:
     - microbatchId
     - fetchMetadata
     - compFormat
     - uncompSize
     - selfInfo
    """


    def __init__(self, microbatchId=None, fetchMetadata=None, compFormat=None, uncompSize=None, selfInfo=None,):
        self.microbatchId = microbatchId
        self.fetchMetadata = fetchMetadata
        self.compFormat = compFormat
        self.uncompSize = uncompSize
        self.selfInfo = selfInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.microbatchId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.fetchMetadata = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.compFormat = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.uncompSize = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.selfInfo = EdgeInfoData()
                    self.selfInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getData_args')
        if self.microbatchId is not None:
            oprot.writeFieldBegin('microbatchId', TType.I64, 1)
            oprot.writeI64(self.microbatchId)
            oprot.writeFieldEnd()
        if self.fetchMetadata is not None:
            oprot.writeFieldBegin('fetchMetadata', TType.BOOL, 2)
            oprot.writeBool(self.fetchMetadata)
            oprot.writeFieldEnd()
        if self.compFormat is not None:
            oprot.writeFieldBegin('compFormat', TType.STRING, 3)
            oprot.writeString(self.compFormat.encode('utf-8') if sys.version_info[0] == 2 else self.compFormat)
            oprot.writeFieldEnd()
        if self.uncompSize is not None:
            oprot.writeFieldBegin('uncompSize', TType.I64, 4)
            oprot.writeI64(self.uncompSize)
            oprot.writeFieldEnd()
        if self.selfInfo is not None:
            oprot.writeFieldBegin('selfInfo', TType.STRUCT, 5)
            self.selfInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getData_args)
getData_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'microbatchId', None, None, ),  # 1
    (2, TType.BOOL, 'fetchMetadata', None, None, ),  # 2
    (3, TType.STRING, 'compFormat', 'UTF8', None, ),  # 3
    (4, TType.I64, 'uncompSize', None, None, ),  # 4
    (5, TType.STRUCT, 'selfInfo', [EdgeInfoData, None], None, ),  # 5
)


class getData_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ReadReplica()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getData_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getData_result)
getData_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ReadReplica, None], None, ),  # 0
)
fix_spec(all_structs)
del all_structs

