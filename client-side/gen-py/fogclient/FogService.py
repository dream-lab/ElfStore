#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    def joinCluster(self, NodeX, pmin, pmax):
        """
        Parameters:
         - NodeX
         - pmin
         - pmax
        """
        pass

    def joinPool(self, NodeX):
        """
        Parameters:
         - NodeX
        """
        pass

    def getCandidatePool(self, reliability, pmin):
        """
        Parameters:
         - reliability
         - pmin
        """
        pass

    def bootstrapFog(self, NodeX):
        """
        Parameters:
         - NodeX
        """
        pass

    def initiate2PhasePreCommit(self, preCommitRequest):
        """
        Parameters:
         - preCommitRequest
        """
        pass

    def initiate2PhaseCommit(self, commitRequest):
        """
        Parameters:
         - commitRequest
        """
        pass

    def buddyHeartBeat(self, payload):
        """
        Parameters:
         - payload
        """
        pass

    def neighborHeartBeat(self, payload):
        """
        Parameters:
         - payload
        """
        pass

    def getPoolMember(self, buddyPoolId):
        """
        Parameters:
         - buddyPoolId
        """
        pass

    def getBuddyPoolMembers(self):
        pass

    def getNeighborCountPerPool(self):
        pass

    def requestNeighbors(self, requestMap):
        """
        Parameters:
         - requestMap
        """
        pass

    def nodeJoiningComplete(self):
        pass

    def subscribe(self, nodeInfoData):
        """
        Parameters:
         - nodeInfoData
        """
        pass

    def edgeHeartBeats(self, edgePayload):
        """
        Parameters:
         - edgePayload
        """
        pass

    def edgeJoin(self, edgeInfoData):
        """
        Parameters:
         - edgeInfoData
        """
        pass

    def edgeLeave(self, edgeInfoData):
        """
        Parameters:
         - edgeInfoData
        """
        pass

    def terminate(self, streamId):
        """
        Parameters:
         - streamId
        """
        pass

    def registerStream(self, streamId, streamMetadata):
        """
        Parameters:
         - streamId
         - streamMetadata
        """
        pass

    def intentToWrite(self, clientId):
        """
        Parameters:
         - clientId
        """
        pass

    def getStreamMetadata(self, streamId, checkNeighbors, checkBuddies):
        """
        Parameters:
         - streamId
         - checkNeighbors
         - checkBuddies
        """
        pass

    def getWriteLocations(self, dataLength, metadata, blackListedFogs, selfInfo):
        """
        Parameters:
         - dataLength
         - metadata
         - blackListedFogs
         - selfInfo
        """
        pass

    def write(self, mbMetadata, data, preference):
        """
        Parameters:
         - mbMetadata
         - data
         - preference
        """
        pass

    def writeNext(self, sessionId, mbData, dataLength):
        """
        Parameters:
         - sessionId
         - mbData
         - dataLength
        """
        pass

    def insertMetadata(self, mbMetadata, edgeInfoData):
        """
        Parameters:
         - mbMetadata
         - edgeInfoData
        """
        pass

    def findNext(self, microbatchId):
        """
        Parameters:
         - microbatchId
        """
        pass

    def find(self, microbatchId, checkNeighbors, checkBuddies, selfInfo):
        """
        Parameters:
         - microbatchId
         - checkNeighbors
         - checkBuddies
         - selfInfo
        """
        pass

    def read(self, microbatchId, fetchMetadata):
        """
        Parameters:
         - microbatchId
         - fetchMetadata
        """
        pass

    def findUsingQuery(self, metadataKey, metadataValue, checkNeighbors, checkBuddies):
        """
        Parameters:
         - metadataKey
         - metadataValue
         - checkNeighbors
         - checkBuddies
        """
        pass


class Client(Iface):
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def joinCluster(self, NodeX, pmin, pmax):
        """
        Parameters:
         - NodeX
         - pmin
         - pmax
        """
        self.send_joinCluster(NodeX, pmin, pmax)
        return self.recv_joinCluster()

    def send_joinCluster(self, NodeX, pmin, pmax):
        self._oprot.writeMessageBegin('joinCluster', TMessageType.CALL, self._seqid)
        args = joinCluster_args()
        args.NodeX = NodeX
        args.pmin = pmin
        args.pmax = pmax
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_joinCluster(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = joinCluster_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "joinCluster failed: unknown result")

    def joinPool(self, NodeX):
        """
        Parameters:
         - NodeX
        """
        self.send_joinPool(NodeX)
        return self.recv_joinPool()

    def send_joinPool(self, NodeX):
        self._oprot.writeMessageBegin('joinPool', TMessageType.CALL, self._seqid)
        args = joinPool_args()
        args.NodeX = NodeX
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_joinPool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = joinPool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "joinPool failed: unknown result")

    def getCandidatePool(self, reliability, pmin):
        """
        Parameters:
         - reliability
         - pmin
        """
        self.send_getCandidatePool(reliability, pmin)
        return self.recv_getCandidatePool()

    def send_getCandidatePool(self, reliability, pmin):
        self._oprot.writeMessageBegin('getCandidatePool', TMessageType.CALL, self._seqid)
        args = getCandidatePool_args()
        args.reliability = reliability
        args.pmin = pmin
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getCandidatePool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getCandidatePool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getCandidatePool failed: unknown result")

    def bootstrapFog(self, NodeX):
        """
        Parameters:
         - NodeX
        """
        self.send_bootstrapFog(NodeX)
        return self.recv_bootstrapFog()

    def send_bootstrapFog(self, NodeX):
        self._oprot.writeMessageBegin('bootstrapFog', TMessageType.CALL, self._seqid)
        args = bootstrapFog_args()
        args.NodeX = NodeX
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_bootstrapFog(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = bootstrapFog_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "bootstrapFog failed: unknown result")

    def initiate2PhasePreCommit(self, preCommitRequest):
        """
        Parameters:
         - preCommitRequest
        """
        self.send_initiate2PhasePreCommit(preCommitRequest)
        return self.recv_initiate2PhasePreCommit()

    def send_initiate2PhasePreCommit(self, preCommitRequest):
        self._oprot.writeMessageBegin('initiate2PhasePreCommit', TMessageType.CALL, self._seqid)
        args = initiate2PhasePreCommit_args()
        args.preCommitRequest = preCommitRequest
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_initiate2PhasePreCommit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = initiate2PhasePreCommit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "initiate2PhasePreCommit failed: unknown result")

    def initiate2PhaseCommit(self, commitRequest):
        """
        Parameters:
         - commitRequest
        """
        self.send_initiate2PhaseCommit(commitRequest)
        return self.recv_initiate2PhaseCommit()

    def send_initiate2PhaseCommit(self, commitRequest):
        self._oprot.writeMessageBegin('initiate2PhaseCommit', TMessageType.CALL, self._seqid)
        args = initiate2PhaseCommit_args()
        args.commitRequest = commitRequest
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_initiate2PhaseCommit(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = initiate2PhaseCommit_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "initiate2PhaseCommit failed: unknown result")

    def buddyHeartBeat(self, payload):
        """
        Parameters:
         - payload
        """
        self.send_buddyHeartBeat(payload)

    def send_buddyHeartBeat(self, payload):
        self._oprot.writeMessageBegin('buddyHeartBeat', TMessageType.ONEWAY, self._seqid)
        args = buddyHeartBeat_args()
        args.payload = payload
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def neighborHeartBeat(self, payload):
        """
        Parameters:
         - payload
        """
        self.send_neighborHeartBeat(payload)

    def send_neighborHeartBeat(self, payload):
        self._oprot.writeMessageBegin('neighborHeartBeat', TMessageType.ONEWAY, self._seqid)
        args = neighborHeartBeat_args()
        args.payload = payload
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def getPoolMember(self, buddyPoolId):
        """
        Parameters:
         - buddyPoolId
        """
        self.send_getPoolMember(buddyPoolId)
        return self.recv_getPoolMember()

    def send_getPoolMember(self, buddyPoolId):
        self._oprot.writeMessageBegin('getPoolMember', TMessageType.CALL, self._seqid)
        args = getPoolMember_args()
        args.buddyPoolId = buddyPoolId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getPoolMember(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getPoolMember_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getPoolMember failed: unknown result")

    def getBuddyPoolMembers(self):
        self.send_getBuddyPoolMembers()
        return self.recv_getBuddyPoolMembers()

    def send_getBuddyPoolMembers(self):
        self._oprot.writeMessageBegin('getBuddyPoolMembers', TMessageType.CALL, self._seqid)
        args = getBuddyPoolMembers_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getBuddyPoolMembers(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getBuddyPoolMembers_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getBuddyPoolMembers failed: unknown result")

    def getNeighborCountPerPool(self):
        self.send_getNeighborCountPerPool()
        return self.recv_getNeighborCountPerPool()

    def send_getNeighborCountPerPool(self):
        self._oprot.writeMessageBegin('getNeighborCountPerPool', TMessageType.CALL, self._seqid)
        args = getNeighborCountPerPool_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getNeighborCountPerPool(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getNeighborCountPerPool_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getNeighborCountPerPool failed: unknown result")

    def requestNeighbors(self, requestMap):
        """
        Parameters:
         - requestMap
        """
        self.send_requestNeighbors(requestMap)
        return self.recv_requestNeighbors()

    def send_requestNeighbors(self, requestMap):
        self._oprot.writeMessageBegin('requestNeighbors', TMessageType.CALL, self._seqid)
        args = requestNeighbors_args()
        args.requestMap = requestMap
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_requestNeighbors(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = requestNeighbors_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "requestNeighbors failed: unknown result")

    def nodeJoiningComplete(self):
        self.send_nodeJoiningComplete()
        self.recv_nodeJoiningComplete()

    def send_nodeJoiningComplete(self):
        self._oprot.writeMessageBegin('nodeJoiningComplete', TMessageType.CALL, self._seqid)
        args = nodeJoiningComplete_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_nodeJoiningComplete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = nodeJoiningComplete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def subscribe(self, nodeInfoData):
        """
        Parameters:
         - nodeInfoData
        """
        self.send_subscribe(nodeInfoData)
        return self.recv_subscribe()

    def send_subscribe(self, nodeInfoData):
        self._oprot.writeMessageBegin('subscribe', TMessageType.CALL, self._seqid)
        args = subscribe_args()
        args.nodeInfoData = nodeInfoData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_subscribe(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = subscribe_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "subscribe failed: unknown result")

    def edgeHeartBeats(self, edgePayload):
        """
        Parameters:
         - edgePayload
        """
        self.send_edgeHeartBeats(edgePayload)
        return self.recv_edgeHeartBeats()

    def send_edgeHeartBeats(self, edgePayload):
        self._oprot.writeMessageBegin('edgeHeartBeats', TMessageType.CALL, self._seqid)
        args = edgeHeartBeats_args()
        args.edgePayload = edgePayload
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_edgeHeartBeats(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = edgeHeartBeats_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "edgeHeartBeats failed: unknown result")

    def edgeJoin(self, edgeInfoData):
        """
        Parameters:
         - edgeInfoData
        """
        self.send_edgeJoin(edgeInfoData)
        return self.recv_edgeJoin()

    def send_edgeJoin(self, edgeInfoData):
        self._oprot.writeMessageBegin('edgeJoin', TMessageType.CALL, self._seqid)
        args = edgeJoin_args()
        args.edgeInfoData = edgeInfoData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_edgeJoin(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = edgeJoin_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "edgeJoin failed: unknown result")

    def edgeLeave(self, edgeInfoData):
        """
        Parameters:
         - edgeInfoData
        """
        self.send_edgeLeave(edgeInfoData)
        return self.recv_edgeLeave()

    def send_edgeLeave(self, edgeInfoData):
        self._oprot.writeMessageBegin('edgeLeave', TMessageType.CALL, self._seqid)
        args = edgeLeave_args()
        args.edgeInfoData = edgeInfoData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_edgeLeave(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = edgeLeave_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "edgeLeave failed: unknown result")

    def terminate(self, streamId):
        """
        Parameters:
         - streamId
        """
        self.send_terminate(streamId)
        return self.recv_terminate()

    def send_terminate(self, streamId):
        self._oprot.writeMessageBegin('terminate', TMessageType.CALL, self._seqid)
        args = terminate_args()
        args.streamId = streamId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_terminate(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = terminate_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "terminate failed: unknown result")

    def registerStream(self, streamId, streamMetadata):
        """
        Parameters:
         - streamId
         - streamMetadata
        """
        self.send_registerStream(streamId, streamMetadata)
        return self.recv_registerStream()

    def send_registerStream(self, streamId, streamMetadata):
        self._oprot.writeMessageBegin('registerStream', TMessageType.CALL, self._seqid)
        args = registerStream_args()
        args.streamId = streamId
        args.streamMetadata = streamMetadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_registerStream(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = registerStream_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "registerStream failed: unknown result")

    def intentToWrite(self, clientId):
        """
        Parameters:
         - clientId
        """
        self.send_intentToWrite(clientId)
        return self.recv_intentToWrite()

    def send_intentToWrite(self, clientId):
        self._oprot.writeMessageBegin('intentToWrite', TMessageType.CALL, self._seqid)
        args = intentToWrite_args()
        args.clientId = clientId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_intentToWrite(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = intentToWrite_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "intentToWrite failed: unknown result")

    def getStreamMetadata(self, streamId, checkNeighbors, checkBuddies):
        """
        Parameters:
         - streamId
         - checkNeighbors
         - checkBuddies
        """
        self.send_getStreamMetadata(streamId, checkNeighbors, checkBuddies)
        return self.recv_getStreamMetadata()

    def send_getStreamMetadata(self, streamId, checkNeighbors, checkBuddies):
        self._oprot.writeMessageBegin('getStreamMetadata', TMessageType.CALL, self._seqid)
        args = getStreamMetadata_args()
        args.streamId = streamId
        args.checkNeighbors = checkNeighbors
        args.checkBuddies = checkBuddies
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getStreamMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getStreamMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getStreamMetadata failed: unknown result")

    def getWriteLocations(self, dataLength, metadata, blackListedFogs, selfInfo):
        """
        Parameters:
         - dataLength
         - metadata
         - blackListedFogs
         - selfInfo
        """
        self.send_getWriteLocations(dataLength, metadata, blackListedFogs, selfInfo)
        return self.recv_getWriteLocations()

    def send_getWriteLocations(self, dataLength, metadata, blackListedFogs, selfInfo):
        self._oprot.writeMessageBegin('getWriteLocations', TMessageType.CALL, self._seqid)
        args = getWriteLocations_args()
        args.dataLength = dataLength
        args.metadata = metadata
        args.blackListedFogs = blackListedFogs
        args.selfInfo = selfInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getWriteLocations(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getWriteLocations_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getWriteLocations failed: unknown result")

    def write(self, mbMetadata, data, preference):
        """
        Parameters:
         - mbMetadata
         - data
         - preference
        """
        self.send_write(mbMetadata, data, preference)
        return self.recv_write()

    def send_write(self, mbMetadata, data, preference):
        self._oprot.writeMessageBegin('write', TMessageType.CALL, self._seqid)
        args = write_args()
        args.mbMetadata = mbMetadata
        args.data = data
        args.preference = preference
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_write(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = write_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "write failed: unknown result")

    def writeNext(self, sessionId, mbData, dataLength):
        """
        Parameters:
         - sessionId
         - mbData
         - dataLength
        """
        self.send_writeNext(sessionId, mbData, dataLength)
        return self.recv_writeNext()

    def send_writeNext(self, sessionId, mbData, dataLength):
        self._oprot.writeMessageBegin('writeNext', TMessageType.CALL, self._seqid)
        args = writeNext_args()
        args.sessionId = sessionId
        args.mbData = mbData
        args.dataLength = dataLength
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_writeNext(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = writeNext_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "writeNext failed: unknown result")

    def insertMetadata(self, mbMetadata, edgeInfoData):
        """
        Parameters:
         - mbMetadata
         - edgeInfoData
        """
        self.send_insertMetadata(mbMetadata, edgeInfoData)
        return self.recv_insertMetadata()

    def send_insertMetadata(self, mbMetadata, edgeInfoData):
        self._oprot.writeMessageBegin('insertMetadata', TMessageType.CALL, self._seqid)
        args = insertMetadata_args()
        args.mbMetadata = mbMetadata
        args.edgeInfoData = edgeInfoData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_insertMetadata(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = insertMetadata_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "insertMetadata failed: unknown result")

    def findNext(self, microbatchId):
        """
        Parameters:
         - microbatchId
        """
        self.send_findNext(microbatchId)
        return self.recv_findNext()

    def send_findNext(self, microbatchId):
        self._oprot.writeMessageBegin('findNext', TMessageType.CALL, self._seqid)
        args = findNext_args()
        args.microbatchId = microbatchId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findNext(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findNext_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findNext failed: unknown result")

    def find(self, microbatchId, checkNeighbors, checkBuddies, selfInfo):
        """
        Parameters:
         - microbatchId
         - checkNeighbors
         - checkBuddies
         - selfInfo
        """
        self.send_find(microbatchId, checkNeighbors, checkBuddies, selfInfo)
        return self.recv_find()

    def send_find(self, microbatchId, checkNeighbors, checkBuddies, selfInfo):
        self._oprot.writeMessageBegin('find', TMessageType.CALL, self._seqid)
        args = find_args()
        args.microbatchId = microbatchId
        args.checkNeighbors = checkNeighbors
        args.checkBuddies = checkBuddies
        args.selfInfo = selfInfo
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_find(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = find_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "find failed: unknown result")

    def read(self, microbatchId, fetchMetadata):
        """
        Parameters:
         - microbatchId
         - fetchMetadata
        """
        self.send_read(microbatchId, fetchMetadata)
        return self.recv_read()

    def send_read(self, microbatchId, fetchMetadata):
        self._oprot.writeMessageBegin('read', TMessageType.CALL, self._seqid)
        args = read_args()
        args.microbatchId = microbatchId
        args.fetchMetadata = fetchMetadata
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_read(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = read_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "read failed: unknown result")

    def findUsingQuery(self, metadataKey, metadataValue, checkNeighbors, checkBuddies):
        """
        Parameters:
         - metadataKey
         - metadataValue
         - checkNeighbors
         - checkBuddies
        """
        self.send_findUsingQuery(metadataKey, metadataValue, checkNeighbors, checkBuddies)
        return self.recv_findUsingQuery()

    def send_findUsingQuery(self, metadataKey, metadataValue, checkNeighbors, checkBuddies):
        self._oprot.writeMessageBegin('findUsingQuery', TMessageType.CALL, self._seqid)
        args = findUsingQuery_args()
        args.metadataKey = metadataKey
        args.metadataValue = metadataValue
        args.checkNeighbors = checkNeighbors
        args.checkBuddies = checkBuddies
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_findUsingQuery(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = findUsingQuery_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "findUsingQuery failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["joinCluster"] = Processor.process_joinCluster
        self._processMap["joinPool"] = Processor.process_joinPool
        self._processMap["getCandidatePool"] = Processor.process_getCandidatePool
        self._processMap["bootstrapFog"] = Processor.process_bootstrapFog
        self._processMap["initiate2PhasePreCommit"] = Processor.process_initiate2PhasePreCommit
        self._processMap["initiate2PhaseCommit"] = Processor.process_initiate2PhaseCommit
        self._processMap["buddyHeartBeat"] = Processor.process_buddyHeartBeat
        self._processMap["neighborHeartBeat"] = Processor.process_neighborHeartBeat
        self._processMap["getPoolMember"] = Processor.process_getPoolMember
        self._processMap["getBuddyPoolMembers"] = Processor.process_getBuddyPoolMembers
        self._processMap["getNeighborCountPerPool"] = Processor.process_getNeighborCountPerPool
        self._processMap["requestNeighbors"] = Processor.process_requestNeighbors
        self._processMap["nodeJoiningComplete"] = Processor.process_nodeJoiningComplete
        self._processMap["subscribe"] = Processor.process_subscribe
        self._processMap["edgeHeartBeats"] = Processor.process_edgeHeartBeats
        self._processMap["edgeJoin"] = Processor.process_edgeJoin
        self._processMap["edgeLeave"] = Processor.process_edgeLeave
        self._processMap["terminate"] = Processor.process_terminate
        self._processMap["registerStream"] = Processor.process_registerStream
        self._processMap["intentToWrite"] = Processor.process_intentToWrite
        self._processMap["getStreamMetadata"] = Processor.process_getStreamMetadata
        self._processMap["getWriteLocations"] = Processor.process_getWriteLocations
        self._processMap["write"] = Processor.process_write
        self._processMap["writeNext"] = Processor.process_writeNext
        self._processMap["insertMetadata"] = Processor.process_insertMetadata
        self._processMap["findNext"] = Processor.process_findNext
        self._processMap["find"] = Processor.process_find
        self._processMap["read"] = Processor.process_read
        self._processMap["findUsingQuery"] = Processor.process_findUsingQuery

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_joinCluster(self, seqid, iprot, oprot):
        args = joinCluster_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = joinCluster_result()
        try:
            result.success = self._handler.joinCluster(args.NodeX, args.pmin, args.pmax)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("joinCluster", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_joinPool(self, seqid, iprot, oprot):
        args = joinPool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = joinPool_result()
        try:
            result.success = self._handler.joinPool(args.NodeX)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("joinPool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getCandidatePool(self, seqid, iprot, oprot):
        args = getCandidatePool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getCandidatePool_result()
        try:
            result.success = self._handler.getCandidatePool(args.reliability, args.pmin)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getCandidatePool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_bootstrapFog(self, seqid, iprot, oprot):
        args = bootstrapFog_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = bootstrapFog_result()
        try:
            result.success = self._handler.bootstrapFog(args.NodeX)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("bootstrapFog", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_initiate2PhasePreCommit(self, seqid, iprot, oprot):
        args = initiate2PhasePreCommit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = initiate2PhasePreCommit_result()
        try:
            result.success = self._handler.initiate2PhasePreCommit(args.preCommitRequest)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("initiate2PhasePreCommit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_initiate2PhaseCommit(self, seqid, iprot, oprot):
        args = initiate2PhaseCommit_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = initiate2PhaseCommit_result()
        try:
            result.success = self._handler.initiate2PhaseCommit(args.commitRequest)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("initiate2PhaseCommit", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_buddyHeartBeat(self, seqid, iprot, oprot):
        args = buddyHeartBeat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.buddyHeartBeat(args.payload)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_neighborHeartBeat(self, seqid, iprot, oprot):
        args = neighborHeartBeat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.neighborHeartBeat(args.payload)
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_getPoolMember(self, seqid, iprot, oprot):
        args = getPoolMember_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getPoolMember_result()
        try:
            result.success = self._handler.getPoolMember(args.buddyPoolId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getPoolMember", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getBuddyPoolMembers(self, seqid, iprot, oprot):
        args = getBuddyPoolMembers_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getBuddyPoolMembers_result()
        try:
            result.success = self._handler.getBuddyPoolMembers()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getBuddyPoolMembers", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getNeighborCountPerPool(self, seqid, iprot, oprot):
        args = getNeighborCountPerPool_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getNeighborCountPerPool_result()
        try:
            result.success = self._handler.getNeighborCountPerPool()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getNeighborCountPerPool", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_requestNeighbors(self, seqid, iprot, oprot):
        args = requestNeighbors_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = requestNeighbors_result()
        try:
            result.success = self._handler.requestNeighbors(args.requestMap)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("requestNeighbors", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_nodeJoiningComplete(self, seqid, iprot, oprot):
        args = nodeJoiningComplete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = nodeJoiningComplete_result()
        try:
            self._handler.nodeJoiningComplete()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("nodeJoiningComplete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_subscribe(self, seqid, iprot, oprot):
        args = subscribe_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = subscribe_result()
        try:
            result.success = self._handler.subscribe(args.nodeInfoData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("subscribe", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_edgeHeartBeats(self, seqid, iprot, oprot):
        args = edgeHeartBeats_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = edgeHeartBeats_result()
        try:
            result.success = self._handler.edgeHeartBeats(args.edgePayload)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("edgeHeartBeats", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_edgeJoin(self, seqid, iprot, oprot):
        args = edgeJoin_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = edgeJoin_result()
        try:
            result.success = self._handler.edgeJoin(args.edgeInfoData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("edgeJoin", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_edgeLeave(self, seqid, iprot, oprot):
        args = edgeLeave_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = edgeLeave_result()
        try:
            result.success = self._handler.edgeLeave(args.edgeInfoData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("edgeLeave", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_terminate(self, seqid, iprot, oprot):
        args = terminate_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = terminate_result()
        try:
            result.success = self._handler.terminate(args.streamId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("terminate", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_registerStream(self, seqid, iprot, oprot):
        args = registerStream_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = registerStream_result()
        try:
            result.success = self._handler.registerStream(args.streamId, args.streamMetadata)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("registerStream", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_intentToWrite(self, seqid, iprot, oprot):
        args = intentToWrite_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = intentToWrite_result()
        try:
            result.success = self._handler.intentToWrite(args.clientId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("intentToWrite", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getStreamMetadata(self, seqid, iprot, oprot):
        args = getStreamMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getStreamMetadata_result()
        try:
            result.success = self._handler.getStreamMetadata(args.streamId, args.checkNeighbors, args.checkBuddies)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getStreamMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getWriteLocations(self, seqid, iprot, oprot):
        args = getWriteLocations_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getWriteLocations_result()
        try:
            result.success = self._handler.getWriteLocations(args.dataLength, args.metadata, args.blackListedFogs, args.selfInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getWriteLocations", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_write(self, seqid, iprot, oprot):
        args = write_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = write_result()
        try:
            result.success = self._handler.write(args.mbMetadata, args.data, args.preference)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("write", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_writeNext(self, seqid, iprot, oprot):
        args = writeNext_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = writeNext_result()
        try:
            result.success = self._handler.writeNext(args.sessionId, args.mbData, args.dataLength)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("writeNext", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_insertMetadata(self, seqid, iprot, oprot):
        args = insertMetadata_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = insertMetadata_result()
        try:
            result.success = self._handler.insertMetadata(args.mbMetadata, args.edgeInfoData)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("insertMetadata", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findNext(self, seqid, iprot, oprot):
        args = findNext_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findNext_result()
        try:
            result.success = self._handler.findNext(args.microbatchId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findNext", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_find(self, seqid, iprot, oprot):
        args = find_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = find_result()
        try:
            result.success = self._handler.find(args.microbatchId, args.checkNeighbors, args.checkBuddies, args.selfInfo)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("find", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_read(self, seqid, iprot, oprot):
        args = read_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = read_result()
        try:
            result.success = self._handler.read(args.microbatchId, args.fetchMetadata)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("read", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_findUsingQuery(self, seqid, iprot, oprot):
        args = findUsingQuery_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = findUsingQuery_result()
        try:
            result.success = self._handler.findUsingQuery(args.metadataKey, args.metadataValue, args.checkNeighbors, args.checkBuddies)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("findUsingQuery", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class joinCluster_args(object):
    """
    Attributes:
     - NodeX
     - pmin
     - pmax
    """


    def __init__(self, NodeX=None, pmin=None, pmax=None,):
        self.NodeX = NodeX
        self.pmin = pmin
        self.pmax = pmax

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.NodeX = FogInfoData()
                    self.NodeX.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.pmin = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.pmax = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('joinCluster_args')
        if self.NodeX is not None:
            oprot.writeFieldBegin('NodeX', TType.STRUCT, 1)
            self.NodeX.write(oprot)
            oprot.writeFieldEnd()
        if self.pmin is not None:
            oprot.writeFieldBegin('pmin', TType.I16, 2)
            oprot.writeI16(self.pmin)
            oprot.writeFieldEnd()
        if self.pmax is not None:
            oprot.writeFieldBegin('pmax', TType.I16, 3)
            oprot.writeI16(self.pmax)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(joinCluster_args)
joinCluster_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'NodeX', [FogInfoData, None], None, ),  # 1
    (2, TType.I16, 'pmin', None, None, ),  # 2
    (3, TType.I16, 'pmax', None, None, ),  # 3
)


class joinCluster_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype51, _size48) = iprot.readListBegin()
                    for _i52 in range(_size48):
                        _elem53 = NeighborInfoData()
                        _elem53.read(iprot)
                        self.success.append(_elem53)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('joinCluster_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter54 in self.success:
                iter54.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(joinCluster_result)
joinCluster_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [NeighborInfoData, None], False), None, ),  # 0
)


class joinPool_args(object):
    """
    Attributes:
     - NodeX
    """


    def __init__(self, NodeX=None,):
        self.NodeX = NodeX

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.NodeX = FogInfoData()
                    self.NodeX.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('joinPool_args')
        if self.NodeX is not None:
            oprot.writeFieldBegin('NodeX', TType.STRUCT, 1)
            self.NodeX.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(joinPool_args)
joinPool_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'NodeX', [FogInfoData, None], None, ),  # 1
)


class joinPool_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TwoPhaseCommitResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('joinPool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(joinPool_result)
joinPool_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TwoPhaseCommitResponse, None], None, ),  # 0
)


class getCandidatePool_args(object):
    """
    Attributes:
     - reliability
     - pmin
    """


    def __init__(self, reliability=None, pmin=None,):
        self.reliability = reliability
        self.pmin = pmin

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.DOUBLE:
                    self.reliability = iprot.readDouble()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I16:
                    self.pmin = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCandidatePool_args')
        if self.reliability is not None:
            oprot.writeFieldBegin('reliability', TType.DOUBLE, 1)
            oprot.writeDouble(self.reliability)
            oprot.writeFieldEnd()
        if self.pmin is not None:
            oprot.writeFieldBegin('pmin', TType.I16, 2)
            oprot.writeI16(self.pmin)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCandidatePool_args)
getCandidatePool_args.thrift_spec = (
    None,  # 0
    (1, TType.DOUBLE, 'reliability', None, None, ),  # 1
    (2, TType.I16, 'pmin', None, None, ),  # 2
)


class getCandidatePool_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype58, _size55) = iprot.readListBegin()
                    for _i59 in range(_size55):
                        _elem60 = NeighborInfoData()
                        _elem60.read(iprot)
                        self.success.append(_elem60)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getCandidatePool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter61 in self.success:
                iter61.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getCandidatePool_result)
getCandidatePool_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [NeighborInfoData, None], False), None, ),  # 0
)


class bootstrapFog_args(object):
    """
    Attributes:
     - NodeX
    """


    def __init__(self, NodeX=None,):
        self.NodeX = NodeX

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.NodeX = FogInfoData()
                    self.NodeX.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('bootstrapFog_args')
        if self.NodeX is not None:
            oprot.writeFieldBegin('NodeX', TType.STRUCT, 1)
            self.NodeX.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(bootstrapFog_args)
bootstrapFog_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'NodeX', [FogInfoData, None], None, ),  # 1
)


class bootstrapFog_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('bootstrapFog_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(bootstrapFog_result)
bootstrapFog_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class initiate2PhasePreCommit_args(object):
    """
    Attributes:
     - preCommitRequest
    """


    def __init__(self, preCommitRequest=None,):
        self.preCommitRequest = preCommitRequest

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.preCommitRequest = TwoPhasePreCommitRequest()
                    self.preCommitRequest.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initiate2PhasePreCommit_args')
        if self.preCommitRequest is not None:
            oprot.writeFieldBegin('preCommitRequest', TType.STRUCT, 1)
            self.preCommitRequest.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initiate2PhasePreCommit_args)
initiate2PhasePreCommit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'preCommitRequest', [TwoPhasePreCommitRequest, None], None, ),  # 1
)


class initiate2PhasePreCommit_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TwoPhasePreCommitResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initiate2PhasePreCommit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initiate2PhasePreCommit_result)
initiate2PhasePreCommit_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TwoPhasePreCommitResponse, None], None, ),  # 0
)


class initiate2PhaseCommit_args(object):
    """
    Attributes:
     - commitRequest
    """


    def __init__(self, commitRequest=None,):
        self.commitRequest = commitRequest

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.commitRequest = TwoPhaseCommitRequest()
                    self.commitRequest.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initiate2PhaseCommit_args')
        if self.commitRequest is not None:
            oprot.writeFieldBegin('commitRequest', TType.STRUCT, 1)
            self.commitRequest.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initiate2PhaseCommit_args)
initiate2PhaseCommit_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'commitRequest', [TwoPhaseCommitRequest, None], None, ),  # 1
)


class initiate2PhaseCommit_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TwoPhaseCommitResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('initiate2PhaseCommit_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(initiate2PhaseCommit_result)
initiate2PhaseCommit_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TwoPhaseCommitResponse, None], None, ),  # 0
)


class buddyHeartBeat_args(object):
    """
    Attributes:
     - payload
    """


    def __init__(self, payload=None,):
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.payload = BuddyPayload()
                    self.payload.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('buddyHeartBeat_args')
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRUCT, 1)
            self.payload.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(buddyHeartBeat_args)
buddyHeartBeat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'payload', [BuddyPayload, None], None, ),  # 1
)


class neighborHeartBeat_args(object):
    """
    Attributes:
     - payload
    """


    def __init__(self, payload=None,):
        self.payload = payload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.payload = NeighborPayload()
                    self.payload.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('neighborHeartBeat_args')
        if self.payload is not None:
            oprot.writeFieldBegin('payload', TType.STRUCT, 1)
            self.payload.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(neighborHeartBeat_args)
neighborHeartBeat_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'payload', [NeighborPayload, None], None, ),  # 1
)


class getPoolMember_args(object):
    """
    Attributes:
     - buddyPoolId
    """


    def __init__(self, buddyPoolId=None,):
        self.buddyPoolId = buddyPoolId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I16:
                    self.buddyPoolId = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPoolMember_args')
        if self.buddyPoolId is not None:
            oprot.writeFieldBegin('buddyPoolId', TType.I16, 1)
            oprot.writeI16(self.buddyPoolId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPoolMember_args)
getPoolMember_args.thrift_spec = (
    None,  # 0
    (1, TType.I16, 'buddyPoolId', None, None, ),  # 1
)


class getPoolMember_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NodeInfoData()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getPoolMember_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getPoolMember_result)
getPoolMember_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NodeInfoData, None], None, ),  # 0
)


class getBuddyPoolMembers_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBuddyPoolMembers_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBuddyPoolMembers_args)
getBuddyPoolMembers_args.thrift_spec = (
)


class getBuddyPoolMembers_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype65, _size62) = iprot.readListBegin()
                    for _i66 in range(_size62):
                        _elem67 = FogInfoData()
                        _elem67.read(iprot)
                        self.success.append(_elem67)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getBuddyPoolMembers_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter68 in self.success:
                iter68.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getBuddyPoolMembers_result)
getBuddyPoolMembers_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [FogInfoData, None], False), None, ),  # 0
)


class getNeighborCountPerPool_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNeighborCountPerPool_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNeighborCountPerPool_args)
getNeighborCountPerPool_args.thrift_spec = (
)


class getNeighborCountPerPool_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NeighborCount()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getNeighborCountPerPool_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getNeighborCountPerPool_result)
getNeighborCountPerPool_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [NeighborCount, None], None, ),  # 0
)


class requestNeighbors_args(object):
    """
    Attributes:
     - requestMap
    """


    def __init__(self, requestMap=None,):
        self.requestMap = requestMap

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.requestMap = {}
                    (_ktype70, _vtype71, _size69) = iprot.readMapBegin()
                    for _i73 in range(_size69):
                        _key74 = iprot.readI16()
                        _val75 = iprot.readI16()
                        self.requestMap[_key74] = _val75
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestNeighbors_args')
        if self.requestMap is not None:
            oprot.writeFieldBegin('requestMap', TType.MAP, 1)
            oprot.writeMapBegin(TType.I16, TType.I16, len(self.requestMap))
            for kiter76, viter77 in self.requestMap.items():
                oprot.writeI16(kiter76)
                oprot.writeI16(viter77)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestNeighbors_args)
requestNeighbors_args.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'requestMap', (TType.I16, None, TType.I16, None, False), None, ),  # 1
)


class requestNeighbors_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype81, _size78) = iprot.readListBegin()
                    for _i82 in range(_size78):
                        _elem83 = NeighborInfoData()
                        _elem83.read(iprot)
                        self.success.append(_elem83)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('requestNeighbors_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter84 in self.success:
                iter84.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(requestNeighbors_result)
requestNeighbors_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [NeighborInfoData, None], False), None, ),  # 0
)


class nodeJoiningComplete_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nodeJoiningComplete_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nodeJoiningComplete_args)
nodeJoiningComplete_args.thrift_spec = (
)


class nodeJoiningComplete_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('nodeJoiningComplete_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(nodeJoiningComplete_result)
nodeJoiningComplete_result.thrift_spec = (
)


class subscribe_args(object):
    """
    Attributes:
     - nodeInfoData
    """


    def __init__(self, nodeInfoData=None,):
        self.nodeInfoData = nodeInfoData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.nodeInfoData = NodeInfoData()
                    self.nodeInfoData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('subscribe_args')
        if self.nodeInfoData is not None:
            oprot.writeFieldBegin('nodeInfoData', TType.STRUCT, 1)
            self.nodeInfoData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(subscribe_args)
subscribe_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'nodeInfoData', [NodeInfoData, None], None, ),  # 1
)


class subscribe_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('subscribe_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(subscribe_result)
subscribe_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class edgeHeartBeats_args(object):
    """
    Attributes:
     - edgePayload
    """


    def __init__(self, edgePayload=None,):
        self.edgePayload = edgePayload

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.edgePayload = EdgePayload()
                    self.edgePayload.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('edgeHeartBeats_args')
        if self.edgePayload is not None:
            oprot.writeFieldBegin('edgePayload', TType.STRUCT, 1)
            self.edgePayload.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(edgeHeartBeats_args)
edgeHeartBeats_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'edgePayload', [EdgePayload, None], None, ),  # 1
)


class edgeHeartBeats_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('edgeHeartBeats_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(edgeHeartBeats_result)
edgeHeartBeats_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
)


class edgeJoin_args(object):
    """
    Attributes:
     - edgeInfoData
    """


    def __init__(self, edgeInfoData=None,):
        self.edgeInfoData = edgeInfoData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.edgeInfoData = EdgeInfoData()
                    self.edgeInfoData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('edgeJoin_args')
        if self.edgeInfoData is not None:
            oprot.writeFieldBegin('edgeInfoData', TType.STRUCT, 1)
            self.edgeInfoData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(edgeJoin_args)
edgeJoin_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'edgeInfoData', [EdgeInfoData, None], None, ),  # 1
)


class edgeJoin_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('edgeJoin_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(edgeJoin_result)
edgeJoin_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class edgeLeave_args(object):
    """
    Attributes:
     - edgeInfoData
    """


    def __init__(self, edgeInfoData=None,):
        self.edgeInfoData = edgeInfoData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.edgeInfoData = EdgeInfoData()
                    self.edgeInfoData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('edgeLeave_args')
        if self.edgeInfoData is not None:
            oprot.writeFieldBegin('edgeInfoData', TType.STRUCT, 1)
            self.edgeInfoData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(edgeLeave_args)
edgeLeave_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'edgeInfoData', [EdgeInfoData, None], None, ),  # 1
)


class edgeLeave_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('edgeLeave_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(edgeLeave_result)
edgeLeave_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class terminate_args(object):
    """
    Attributes:
     - streamId
    """


    def __init__(self, streamId=None,):
        self.streamId = streamId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.streamId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('terminate_args')
        if self.streamId is not None:
            oprot.writeFieldBegin('streamId', TType.STRING, 1)
            oprot.writeString(self.streamId.encode('utf-8') if sys.version_info[0] == 2 else self.streamId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(terminate_args)
terminate_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'streamId', 'UTF8', None, ),  # 1
)


class terminate_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('terminate_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(terminate_result)
terminate_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class registerStream_args(object):
    """
    Attributes:
     - streamId
     - streamMetadata
    """


    def __init__(self, streamId=None, streamMetadata=None,):
        self.streamId = streamId
        self.streamMetadata = streamMetadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.streamId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.streamMetadata = StreamMetadata()
                    self.streamMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('registerStream_args')
        if self.streamId is not None:
            oprot.writeFieldBegin('streamId', TType.STRING, 1)
            oprot.writeString(self.streamId.encode('utf-8') if sys.version_info[0] == 2 else self.streamId)
            oprot.writeFieldEnd()
        if self.streamMetadata is not None:
            oprot.writeFieldBegin('streamMetadata', TType.STRUCT, 2)
            self.streamMetadata.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(registerStream_args)
registerStream_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'streamId', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'streamMetadata', [StreamMetadata, None], None, ),  # 2
)


class registerStream_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('registerStream_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(registerStream_result)
registerStream_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class intentToWrite_args(object):
    """
    Attributes:
     - clientId
    """


    def __init__(self, clientId=None,):
        self.clientId = clientId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.clientId = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('intentToWrite_args')
        if self.clientId is not None:
            oprot.writeFieldBegin('clientId', TType.BYTE, 1)
            oprot.writeByte(self.clientId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(intentToWrite_args)
intentToWrite_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'clientId', None, None, ),  # 1
)


class intentToWrite_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('intentToWrite_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(intentToWrite_result)
intentToWrite_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class getStreamMetadata_args(object):
    """
    Attributes:
     - streamId
     - checkNeighbors
     - checkBuddies
    """


    def __init__(self, streamId=None, checkNeighbors=None, checkBuddies=None,):
        self.streamId = streamId
        self.checkNeighbors = checkNeighbors
        self.checkBuddies = checkBuddies

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.streamId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.checkNeighbors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.checkBuddies = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getStreamMetadata_args')
        if self.streamId is not None:
            oprot.writeFieldBegin('streamId', TType.STRING, 1)
            oprot.writeString(self.streamId.encode('utf-8') if sys.version_info[0] == 2 else self.streamId)
            oprot.writeFieldEnd()
        if self.checkNeighbors is not None:
            oprot.writeFieldBegin('checkNeighbors', TType.BOOL, 2)
            oprot.writeBool(self.checkNeighbors)
            oprot.writeFieldEnd()
        if self.checkBuddies is not None:
            oprot.writeFieldBegin('checkBuddies', TType.BOOL, 3)
            oprot.writeBool(self.checkBuddies)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getStreamMetadata_args)
getStreamMetadata_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'streamId', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'checkNeighbors', None, None, ),  # 2
    (3, TType.BOOL, 'checkBuddies', None, None, ),  # 3
)


class getStreamMetadata_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = StreamMetadata()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getStreamMetadata_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getStreamMetadata_result)
getStreamMetadata_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [StreamMetadata, None], None, ),  # 0
)


class getWriteLocations_args(object):
    """
    Attributes:
     - dataLength
     - metadata
     - blackListedFogs
     - selfInfo
    """


    def __init__(self, dataLength=None, metadata=None, blackListedFogs=None, selfInfo=None,):
        self.dataLength = dataLength
        self.metadata = metadata
        self.blackListedFogs = blackListedFogs
        self.selfInfo = selfInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BYTE:
                    self.dataLength = iprot.readByte()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.metadata = Metadata()
                    self.metadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.blackListedFogs = []
                    (_etype88, _size85) = iprot.readListBegin()
                    for _i89 in range(_size85):
                        _elem90 = iprot.readI16()
                        self.blackListedFogs.append(_elem90)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.selfInfo = EdgeInfoData()
                    self.selfInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getWriteLocations_args')
        if self.dataLength is not None:
            oprot.writeFieldBegin('dataLength', TType.BYTE, 1)
            oprot.writeByte(self.dataLength)
            oprot.writeFieldEnd()
        if self.metadata is not None:
            oprot.writeFieldBegin('metadata', TType.STRUCT, 2)
            self.metadata.write(oprot)
            oprot.writeFieldEnd()
        if self.blackListedFogs is not None:
            oprot.writeFieldBegin('blackListedFogs', TType.LIST, 3)
            oprot.writeListBegin(TType.I16, len(self.blackListedFogs))
            for iter91 in self.blackListedFogs:
                oprot.writeI16(iter91)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.selfInfo is not None:
            oprot.writeFieldBegin('selfInfo', TType.STRUCT, 4)
            self.selfInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getWriteLocations_args)
getWriteLocations_args.thrift_spec = (
    None,  # 0
    (1, TType.BYTE, 'dataLength', None, None, ),  # 1
    (2, TType.STRUCT, 'metadata', [Metadata, None], None, ),  # 2
    (3, TType.LIST, 'blackListedFogs', (TType.I16, None, False), None, ),  # 3
    (4, TType.STRUCT, 'selfInfo', [EdgeInfoData, None], None, ),  # 4
)


class getWriteLocations_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype95, _size92) = iprot.readListBegin()
                    for _i96 in range(_size92):
                        _elem97 = WritableFogData()
                        _elem97.read(iprot)
                        self.success.append(_elem97)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getWriteLocations_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter98 in self.success:
                iter98.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getWriteLocations_result)
getWriteLocations_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [WritableFogData, None], False), None, ),  # 0
)


class write_args(object):
    """
    Attributes:
     - mbMetadata
     - data
     - preference
    """


    def __init__(self, mbMetadata=None, data=None, preference=None,):
        self.mbMetadata = mbMetadata
        self.data = data
        self.preference = preference

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.mbMetadata = Metadata()
                    self.mbMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.data = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.preference = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_args')
        if self.mbMetadata is not None:
            oprot.writeFieldBegin('mbMetadata', TType.STRUCT, 1)
            self.mbMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.data is not None:
            oprot.writeFieldBegin('data', TType.STRING, 2)
            oprot.writeBinary(self.data)
            oprot.writeFieldEnd()
        if self.preference is not None:
            oprot.writeFieldBegin('preference', TType.I32, 3)
            oprot.writeI32(self.preference)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_args)
write_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'mbMetadata', [Metadata, None], None, ),  # 1
    (2, TType.STRING, 'data', 'BINARY', None, ),  # 2
    (3, TType.I32, 'preference', None, None, ),  # 3
)


class write_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('write_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(write_result)
write_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class writeNext_args(object):
    """
    Attributes:
     - sessionId
     - mbData
     - dataLength
    """


    def __init__(self, sessionId=None, mbData=None, dataLength=None,):
        self.sessionId = sessionId
        self.mbData = mbData
        self.dataLength = dataLength

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.sessionId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.mbData = Metadata()
                    self.mbData.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BYTE:
                    self.dataLength = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('writeNext_args')
        if self.sessionId is not None:
            oprot.writeFieldBegin('sessionId', TType.STRING, 1)
            oprot.writeString(self.sessionId.encode('utf-8') if sys.version_info[0] == 2 else self.sessionId)
            oprot.writeFieldEnd()
        if self.mbData is not None:
            oprot.writeFieldBegin('mbData', TType.STRUCT, 2)
            self.mbData.write(oprot)
            oprot.writeFieldEnd()
        if self.dataLength is not None:
            oprot.writeFieldBegin('dataLength', TType.BYTE, 3)
            oprot.writeByte(self.dataLength)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(writeNext_args)
writeNext_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'sessionId', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'mbData', [Metadata, None], None, ),  # 2
    (3, TType.BYTE, 'dataLength', None, None, ),  # 3
)


class writeNext_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype102, _size99) = iprot.readListBegin()
                    for _i103 in range(_size99):
                        _elem104 = NodeInfoData()
                        _elem104.read(iprot)
                        self.success.append(_elem104)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('writeNext_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter105 in self.success:
                iter105.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(writeNext_result)
writeNext_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [NodeInfoData, None], False), None, ),  # 0
)


class insertMetadata_args(object):
    """
    Attributes:
     - mbMetadata
     - edgeInfoData
    """


    def __init__(self, mbMetadata=None, edgeInfoData=None,):
        self.mbMetadata = mbMetadata
        self.edgeInfoData = edgeInfoData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.mbMetadata = Metadata()
                    self.mbMetadata.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.edgeInfoData = EdgeInfoData()
                    self.edgeInfoData.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insertMetadata_args')
        if self.mbMetadata is not None:
            oprot.writeFieldBegin('mbMetadata', TType.STRUCT, 1)
            self.mbMetadata.write(oprot)
            oprot.writeFieldEnd()
        if self.edgeInfoData is not None:
            oprot.writeFieldBegin('edgeInfoData', TType.STRUCT, 2)
            self.edgeInfoData.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insertMetadata_args)
insertMetadata_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'mbMetadata', [Metadata, None], None, ),  # 1
    (2, TType.STRUCT, 'edgeInfoData', [EdgeInfoData, None], None, ),  # 2
)


class insertMetadata_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BYTE:
                    self.success = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('insertMetadata_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BYTE, 0)
            oprot.writeByte(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(insertMetadata_result)
insertMetadata_result.thrift_spec = (
    (0, TType.BYTE, 'success', None, None, ),  # 0
)


class findNext_args(object):
    """
    Attributes:
     - microbatchId
    """


    def __init__(self, microbatchId=None,):
        self.microbatchId = microbatchId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.microbatchId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findNext_args')
        if self.microbatchId is not None:
            oprot.writeFieldBegin('microbatchId', TType.STRING, 1)
            oprot.writeString(self.microbatchId.encode('utf-8') if sys.version_info[0] == 2 else self.microbatchId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findNext_args)
findNext_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'microbatchId', 'UTF8', None, ),  # 1
)


class findNext_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findNext_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeBinary(self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findNext_result)
findNext_result.thrift_spec = (
    (0, TType.STRING, 'success', 'BINARY', None, ),  # 0
)


class find_args(object):
    """
    Attributes:
     - microbatchId
     - checkNeighbors
     - checkBuddies
     - selfInfo
    """


    def __init__(self, microbatchId=None, checkNeighbors=None, checkBuddies=None, selfInfo=None,):
        self.microbatchId = microbatchId
        self.checkNeighbors = checkNeighbors
        self.checkBuddies = checkBuddies
        self.selfInfo = selfInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.microbatchId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.checkNeighbors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.checkBuddies = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.selfInfo = EdgeInfoData()
                    self.selfInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('find_args')
        if self.microbatchId is not None:
            oprot.writeFieldBegin('microbatchId', TType.STRING, 1)
            oprot.writeString(self.microbatchId.encode('utf-8') if sys.version_info[0] == 2 else self.microbatchId)
            oprot.writeFieldEnd()
        if self.checkNeighbors is not None:
            oprot.writeFieldBegin('checkNeighbors', TType.BOOL, 2)
            oprot.writeBool(self.checkNeighbors)
            oprot.writeFieldEnd()
        if self.checkBuddies is not None:
            oprot.writeFieldBegin('checkBuddies', TType.BOOL, 3)
            oprot.writeBool(self.checkBuddies)
            oprot.writeFieldEnd()
        if self.selfInfo is not None:
            oprot.writeFieldBegin('selfInfo', TType.STRUCT, 4)
            self.selfInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(find_args)
find_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'microbatchId', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'checkNeighbors', None, None, ),  # 2
    (3, TType.BOOL, 'checkBuddies', None, None, ),  # 3
    (4, TType.STRUCT, 'selfInfo', [EdgeInfoData, None], None, ),  # 4
)


class find_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype109, _size106) = iprot.readListBegin()
                    for _i110 in range(_size106):
                        _elem111 = FindReplica()
                        _elem111.read(iprot)
                        self.success.append(_elem111)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('find_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter112 in self.success:
                iter112.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(find_result)
find_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [FindReplica, None], False), None, ),  # 0
)


class read_args(object):
    """
    Attributes:
     - microbatchId
     - fetchMetadata
    """


    def __init__(self, microbatchId=None, fetchMetadata=None,):
        self.microbatchId = microbatchId
        self.fetchMetadata = fetchMetadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.microbatchId = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.fetchMetadata = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_args')
        if self.microbatchId is not None:
            oprot.writeFieldBegin('microbatchId', TType.STRING, 1)
            oprot.writeString(self.microbatchId.encode('utf-8') if sys.version_info[0] == 2 else self.microbatchId)
            oprot.writeFieldEnd()
        if self.fetchMetadata is not None:
            oprot.writeFieldBegin('fetchMetadata', TType.BOOL, 2)
            oprot.writeBool(self.fetchMetadata)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_args)
read_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'microbatchId', 'UTF8', None, ),  # 1
    (2, TType.BOOL, 'fetchMetadata', None, None, ),  # 2
)


class read_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ReadReplica()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('read_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(read_result)
read_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [ReadReplica, None], None, ),  # 0
)


class findUsingQuery_args(object):
    """
    Attributes:
     - metadataKey
     - metadataValue
     - checkNeighbors
     - checkBuddies
    """


    def __init__(self, metadataKey=None, metadataValue=None, checkNeighbors=None, checkBuddies=None,):
        self.metadataKey = metadataKey
        self.metadataValue = metadataValue
        self.checkNeighbors = checkNeighbors
        self.checkBuddies = checkBuddies

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.metadataKey = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.metadataValue = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.checkNeighbors = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.checkBuddies = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findUsingQuery_args')
        if self.metadataKey is not None:
            oprot.writeFieldBegin('metadataKey', TType.STRING, 1)
            oprot.writeString(self.metadataKey.encode('utf-8') if sys.version_info[0] == 2 else self.metadataKey)
            oprot.writeFieldEnd()
        if self.metadataValue is not None:
            oprot.writeFieldBegin('metadataValue', TType.STRING, 2)
            oprot.writeString(self.metadataValue.encode('utf-8') if sys.version_info[0] == 2 else self.metadataValue)
            oprot.writeFieldEnd()
        if self.checkNeighbors is not None:
            oprot.writeFieldBegin('checkNeighbors', TType.BOOL, 3)
            oprot.writeBool(self.checkNeighbors)
            oprot.writeFieldEnd()
        if self.checkBuddies is not None:
            oprot.writeFieldBegin('checkBuddies', TType.BOOL, 4)
            oprot.writeBool(self.checkBuddies)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findUsingQuery_args)
findUsingQuery_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'metadataKey', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'metadataValue', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'checkNeighbors', None, None, ),  # 3
    (4, TType.BOOL, 'checkBuddies', None, None, ),  # 4
)


class findUsingQuery_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = QueryReplica()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('findUsingQuery_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(findUsingQuery_result)
findUsingQuery_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [QueryReplica, None], None, ),  # 0
)
fix_spec(all_structs)
del all_structs

